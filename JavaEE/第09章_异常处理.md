# 第09章_异常处理

```java
模块十二回顾:
  1.权限修饰符:
    public -> protected -> 默认 -> private
    
    a.构造一般用public :便于new对象
    b.成员方法一般用public:便于调用
    c.属性一般用private:封装思想
        
  2.final:最终的
    a.修饰类:不能被继承的
    b.修饰方法:不能被重写
    c.修饰局部变量:不能被二次赋值
    d.修饰对象:地址值不能改变,但是对象中的属性值可以改变
    e.修饰成员变量:需要手动赋值,不能二次赋值
        
  3.代码块:
    a.构造代码块:
      {}
      优先于构造方法执行,每new一次,构造代码块就执行一次
    b.静态代码块:
      static{
          
      }
      优先于构造代码块和构造方法执行的,只执行一次
          
   静态代码块>构造代码块>构造方法 -> 从执行顺序上来看
          
    
 4.匿名内部类:
   a.格式1:
     new 接口/抽象类(){
         重写方法
     }.重写的方法();

   b.格式2:
     接口/抽象类 对象名 = new 接口/抽象类(){
         
         重写的方法
     }
     对象名.重写的方法();

模块13重点:
  1.分清楚什么是编译时期异常,什么是运行时期异常
  2.知道处理异常的2种方式
  3.知道finally关键字的使用场景
  4.知道Object是啥
  5.知道Object中toString以及equals方法的作用
  6.知道重写完Object中的toString以及equals方法的作用
```

# 第一章.API文档

```java
1.什么叫做API:Application Programming Interface,简称API,又称之为应用编程接口
             说白了:定义出来的类以及接口,以及其中的方法等
2.为了方便我们去查询开发好的接口以及类,以及其中的方法,会对应提供一个文档 -> API文档
                 
3.API文档作用:查询我们要使用的对象,以及方法,是我们程序员的"字典"  
```

<img src="img/1704185036101.png" alt="1704185036101" style="zoom:80%;" />

<img src="img/1704185224910.png" alt="1704185224910" style="zoom:80%;" />



<img src="img/1704185319987.png" alt="1704185319987" style="zoom:80%;" />



<img src="img/1704185443350.png" alt="1704185443350" style="zoom:80%;" />

# 第二章.异常

## 1.异常介绍

```java
1.概述:代码出现了不正常的现象;在java中,异常都是一个一个的类                
```

<img src="img/1704188467029.png" alt="1704188467029" style="zoom:80%;" />

<img src="img/1704188437280.png" alt="1704188437280" style="zoom:80%;" />

```java
public class Demo01Exception {
    public static void main(String[] args) throws ParseException {
        //错误Error -> StackOverflowError
        //method();

        //运行时期异常 -> ArrayIndexOutOfBoundsException
        int[] arr1 = new int[3];
        //System.out.println(arr1[4]);
        
        /*
          编译时期异常:
           注意看:编译时期异常是我们代码写错了嘛?不是,当我们调用方法的时候
           该方法底层给我们抛了一个编译时期异常,所以导致我们一调用此方法
           一编译,就爆红了
           当我们一旦触发了这个异常,jvm就会将异常信息打印到控制台上,给程序员们看
         */
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String time = "2000-10-10 10:10:10";
        Date date = sdf.parse(time);
        System.out.println(date);
    }

    public static void method(){
        method();
    }
}

```

## 2.异常出现的过程

<img src="img/1704189581288.png" alt="1704189581288" style="zoom:80%;" />

## 3.创建异常对象(了解)

> 创建异常对象,只是为了后面学习如何处理异常,其他的暂时没有啥意义

```java
1.关键字:throw
2.格式: throw new 异常
```

```java
public class Demo03Exception {
    public static void main(String[] args) {
        String s = "a.tx1t";
        method(s);
    }
    public static void method(String s){
        if (!s.endsWith(".txt")){
            //故意创建异常对象,用throw说明此处有异常
            throw new NullPointerException();
        }
        System.out.println("我要执行了");
    }
}
```

## 4.异常处理方式(重点)

### 4.1 异常处理方式一_throws

```java
1.格式:在方法参数和方法体之间位置上写
  throws 异常
2.意义:处理异常
  将异常往上抛
```

```java
public class Demo04Exception {
    public static void main(String[] args)throws FileNotFoundException {
        String s = "a.txt1";
        add(s);//添加功能
        delete();//删除功能
        update();//修改功能
        find();//查询功能
    }


    private static void add(String s)throws FileNotFoundException {
        if (!s.endsWith(".txt")) {
            //故意创建异常
            throw new FileNotFoundException("文件找不到");
        }
        System.out.println("我要执行了");
    }

    private static void find() {
        System.out.println("查询功能");
    }

    private static void update() {
        System.out.println("修改功能");
    }

    private static void delete() {
        System.out.println("删除功能");
    }
}
```

<img src="img/1704192622348.png" alt="1704192622348" style="zoom:80%;" />

### 4.2 异常处理方式一_throws多个异常

```java
1.格式:throws 异常1,异常2
    
2.注意:
  如果throws的多个异常之间有子父类继承关系,我们可以直接throws父类异常
  如果不知道多个异常之间是否有子父类继承关系,我们可以直接throws Exception    
```

```java
public class Demo05Exception {
    public static void main(String[] args)throws /*FileNotFoundException,*//*IOException*/Exception {
        String s = null;
        add(s);//添加功能
        delete();//删除功能
        update();//修改功能
        find();//查询功能
    }


    private static void add(String s)throws /*FileNotFoundException,*//*IOException*/Exception {
        if (s==null){
            //故意造异常
            throw new IOException("IO异常");
        }
        if (!s.endsWith(".txt")) {
            //故意创建异常
            throw new FileNotFoundException("文件找不到");
        }
        System.out.println("我要执行了");
    }

    private static void find() {
        System.out.println("查询功能");
    }

    private static void update() {
        System.out.println("修改功能");
    }

    private static void delete() {
        System.out.println("删除功能");
    }

}
```

### 4.3 异常处理方式二_try...catch

```java
1.格式:
  try{
      可能出现异常的代码
  }catch(异常 对象名){
      处理异常的代码-> 将来开发会将异常信息保存到日志文件中
  }
```

```java
public class Demo06Exception {
    public static void main(String[] args){
        String s = "a.txt1";
        try{
            //int[] arr = null;
            //System.out.println(arr.length);//NullPointerException
            add(s);//添加功能
        }catch (FileNotFoundException e){
            System.out.println(e);
        }

        delete();//删除功能
        update();//修改功能
        find();//查询功能
    }


    private static void add(String s)throws FileNotFoundException {
        if (!s.endsWith(".txt")) {
            //故意创建异常
            throw new FileNotFoundException("文件找不到");
        }
        System.out.println("我要执行了");
    }

    private static void find() {
        System.out.println("查询功能");
    }

    private static void update() {
        System.out.println("修改功能");
    }

    private static void delete() {
        System.out.println("删除功能");
    }

}

```

### 4.4.异常处理方式二_多个catch

```java
1.格式:
  try{
      可能出现异常的代码
  }catch(异常 对象名){
      处理异常的代码-> 将来开发会将异常信息保存到日志文件中
  }catch(异常 对象名){
      处理异常的代码-> 将来开发会将异常信息保存到日志文件中
  }catch(异常 对象名){
      处理异常的代码-> 将来开发会将异常信息保存到日志文件中
  }catch(异常 对象名){
      处理异常的代码-> 将来开发会将异常信息保存到日志文件中
  }...
      
2.注意:
  如果catch的多个异常之间有子父类继承关系,我们可以直接catch父类异常
  如果不知道多个异常之间是否有子父类继承关系,我们也可以直接catch Exception    
```

```java
public class Demo07Exception {
    public static void main(String[] args) {
        String s = null;
       /* try {
            add(s);//添加功能
        }catch (FileNotFoundException e){
            System.out.println(e);
        }catch (IOException e){
            System.out.println(e);
        }*/

        /*try {
            add(s);//添加功能
        }catch (IOException e){
            System.out.println(e);
        }*/

        try {
            add(s);//添加功能
        }catch (Exception e){
            e.printStackTrace();//将详细的异常信息打印到控制台上
        }
        delete();//删除功能
        update();//修改功能
        find();//查询功能
    }


    private static void add(String s) throws FileNotFoundException, IOException {
        if (s == null) {
            //故意造异常
            throw new IOException("IO异常");
        }
        if (!s.endsWith(".txt")) {
            //故意创建异常
            throw new FileNotFoundException("文件找不到");
        }
        System.out.println("我要执行了");
    }

    private static void find() {
        System.out.println("查询功能");
    }

    private static void update() {
        System.out.println("修改功能");
    }

    private static void delete() {
        System.out.println("删除功能");
    }

}

```

## 5.finally关键字

```java
1.概述:代表的是不管是否触发了异常,都会执行的代码块
  特殊情况:如果之前执行了System.exit(0)终止当前正在执行的java虚拟机
2.使用:都是配合try...catch使用
  try{
      可能出现异常的代码
  }catch(异常 对象名){
      处理异常的代码-> 将来开发会将异常信息保存到日志文件中
  }finally{
      不管是否有异常,都会执行的代码
  }  
```

```java
public class Demo08Exception {
    public static void main(String[] args){
        String s = "a.txt";
        try {
            add(s);//添加功能
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }finally {
            System.out.println("我必须滴执行");
        }
    }


    private static void add(String s)throws FileNotFoundException {
        if (!s.endsWith(".txt")) {
            //故意创建异常
            throw new FileNotFoundException("文件找不到");
        }
        System.out.println("我要执行了");
    }
}

```

```java
public class Demo09Exception {
    public static void main(String[] args) {
        int result = method();
        System.out.println(result);
    }

    public static int method() {
        try {
            String s = null;
            System.out.println(s.length());//空指针异常
            return 2;
        } catch (Exception e) {
            return 1;
        } finally {
            System.out.println("我一定要执行");
            //return 3;
        }
    }
}
```

> finally的使用场景:
>
>   1.关闭资源
>
>   2.原因:对象如果没有用了,GC(垃圾回收器)回收,用来回收堆内存中的垃圾,释放内存,但是有一些对象GC回收不了,比如:连接对象(Connection),IO流对象,Socket对象,这些对象GC回收不了,就需要我们自己手动回收,手动关闭
>
> ​      将来不能回收的对象new完之后,后续操作不管是否操作成功,是否有异常,我们都需要手动关闭,此时我们就可以将关闭资源的代码放到finally中
>
> ```java
> public class Test {
>  public static void main(String[] args) {
>      FileWriter fw = null;
>      try {
>          fw = new FileWriter("day13_exception_object\\1.txt");
>          fw.write("哈哈哈");//假如这里写失败或者写成功了
>      } catch (IOException e) {
>          throw new RuntimeException(e);
>      }finally {
>          if (fw!=null){
>              try {
>                  fw.close();
>              } catch (IOException e) {
>                  throw new RuntimeException(e);
>              }
>          }
> 
>      }
>  }
> }
> ```

## 6.抛异常时注意的事项

```java
1.如果父类中的方法抛了异常,那么子类重写之后要不要抛?
  可抛可不抛  
2.如果父类中的方法没有抛异常,那么子类重写之后要不要抛?  
  不要抛  
```

```java
public class Demo10Exception {
    public static void main(String[] args) {

    }
    class A{
        public void method()/*throws Exception*/{

        }
    }

    class B extends A{
        @Override
        public void method()/*throws Exception*/{

        }
    }
}
```

## 7.try_catch和throws的使用时机

```java
1.如果处理异常之后,还想让后续的代码正常执行,我们使用try...catch
2.如果方法之间是递进关系(调用),我们可以先throws,但是到了最后需要用try...catch做一个统一的异常处理
```

<img src="img/1704269702465.png" alt="1704269702465" style="zoom:80%;" />

> 1.编译时期异常是必须要处理的,不处理爆红,没法往下写
>
>    a.throws
>
>    b.try...catch
>
> 2.运行时期异常我们一般不处理,一旦出现运行时期异常,肯定是代码写的有问题,我们直接修改代码细节就行啦

## 8.自定义异常

```java
1.需求:键盘录入一个用户名,实现登录功能,如果登录失败,抛出LoginUserException
```

```java
public class LoginUserException extends Exception{
    public LoginUserException() {
    }

    public LoginUserException(String message) {
        super(message);
    }
}

```

```java
public class Demo11Exception {
    public static void main(String[] args) throws LoginUserException {
        //1.定义一个用户名,代表已经注册的用户
        String username = "root";
        //2.创建Scanner对象,录入用户名
        Scanner sc = new Scanner(System.in);
        System.out.println("请您输入要登录的用户名:");
        String name = sc.next();
        //3.判断用户名是否和已经存在的用户名一致
        if (name.equals(username)){
            System.out.println("登录成功了");
        }else{
            throw new LoginUserException("登录失败了,用户名或者密码有问题");
        }
    }
}

```

> 1.定义一个类
>
> 2.如果继承Exception 就是编译时期异常
>
> 3.如果继承RuntimeException,就是运行时期异常

## 9.打印异常信息的三个方法

```java
Throwable类中的方法:
  String toString()  :输出异常类型和设置的异常信息
  String getMessage(): 输出设置的异常信息  
  void printStackTrace():打印异常信息是最全的:包括异常类型,信息,以及出现的行数等      
```

```java
public class Demo11Exception {
    public static void main(String[] args) {
        //1.定义一个用户名,代表已经注册的用户
        String username = "root";
        //2.创建Scanner对象,录入用户名
        Scanner sc = new Scanner(System.in);
        System.out.println("请您输入要登录的用户名:");
        String name = sc.next();
        //3.判断用户名是否和已经存在的用户名一致
        if (name.equals(username)) {
            System.out.println("登录成功了");
        } else {
            try {
                throw new LoginUserException("登录失败了,用户名或者密码有问题");
            }catch (Exception e){
                //System.out.println(e.toString());
                //System.out.println(e.getMessage());
                e.printStackTrace();
            }
        }
    }
}
```

# 第三章.Object类

```java
1.概述:所有类的根类(父类),所有的类都会直接或者间接继承Object类
```

## 1.Object中的toString

```java
1.Object中的toString方法:返回该对象的字符串表示形式
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }

2.注意:
  a.如果没有重写Object中的toString方法,直接输出对象名会默认调用Object中的toString方法,直接输出地址值
  b.如果重写了Object中的toString方法,再输出地址值,重写没有意义,所以重写完toString之后,应该返回对象的内容  
      
3.总结:
  如果直接输出对象名不想输出地址值,就重写Object中的toString方法
```

```java
public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

```java
public class Test01 {
    public static void main(String[] args) {
        Person p1 = new Person("金莲", 26);
        System.out.println(p1);//com.atguigu.b_object.Person@4eec7777
        System.out.println(p1.toString());//com.atguigu.b_object.Person@4eec7777

        System.out.println("==============");

        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        System.out.println(list);//[张三, 李四, 王五]
        System.out.println(list.toString());//[张三, 李四, 王五]
    }
}
```

> 快速生成toString
>
> alt+insert -> 选择toString -> 直接下一步

## 2.Object中的equals

```java
1.概述:比较两个对象的地址值是否相等
    public boolean equals(Object obj) {
        return (this == obj);
    }

    == 针对于基本数据类型来说,比较的是值 
    == 针对于引用数据类型来说,比较的是地址值
        
2.注意:
  a.如果没有重写Object中的equals方法,那么就会调用Object中的equals方法,比较对象的地址值
  b.如果重写了Object中的equals方法,那么就会调用重写后的equals方法,应该比较对象的内容
```

```java
public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    /*
       问题1:obj直接调用name和age调用不了,因为Object接收了Person类型的对象
            属于多态,多态前提下不能直接调用子类特有内容
       解决问题1:向下转型

       问题2:如果传递的不是Person类型,就会出现类型转换异常
       解决问题2:先判断类型,如果是Person类型,再强转成Person

       问题3:如果传递null呢?,就不用判断类型了,直接给false

       问题4:如果传递自己呢?就不用判断非空了,也不同判断类型了,直接给true
     */
   /* public boolean equals(Object obj){
        if (this==obj){
            return true;
        }

        if (obj==null){
            return false;
        }

        if (obj instanceof Person){
            Person p = (Person) obj;
            return this.name.equals(p.name)&&this.age==p.age;
        }
        return false;

    }*/

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }
    
}
```

```java
public class Test02 {
    public static void main(String[] args) {
        Person p1 = new Person("金莲", 26);
        Person p2 = new Person("金莲", 26);
        System.out.println(p1==p2);//false
        System.out.println(p1.equals(p2));//false & true
        System.out.println("==============");


        ArrayList<String> list = new ArrayList<>();
        System.out.println(p1.equals(list));

        System.out.println("==============");

        System.out.println(p1.equals(null));

        System.out.println("==============");
        System.out.println(p1.equals(p1));

        System.out.println("====================");

        String s1 = new String("abc");
        String s2 = new String("abc");
        System.out.println(s1.equals(s2));//true
    }
}

```

<img src="img/1704276772548.png" alt="1704276772548" style="zoom:80%;" />

> 小结:
>
>   1.如果直接输出对象名不想输出地址值,重写toString方法
>
>   2.如果想比较两个对象的内容,就重写一下equals方法
>
>   3.怎么重写:alt+insert -> 选toString 或者equals and hashcode -> 啥也不要管 -> 一路下一步即可

## 3.Object中的clone方法

```java
1.作用:复制一个属性值一样的新对象
2.使用:
  需要被克隆的对象实现Cloneable
  重写clone方法
```

```java
public class Person implements Cloneable{
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    /*
       问题1:obj直接调用name和age调用不了,因为Object接收了Person类型的对象
            属于多态,多态前提下不能直接调用子类特有内容
       解决问题1:向下转型

       问题2:如果传递的不是Person类型,就会出现类型转换异常
       解决问题2:先判断类型,如果是Person类型,再强转成Person

       问题3:如果传递null呢?,就不用判断类型了,直接给false

       问题4:如果传递自己呢?就不用判断非空了,也不同判断类型了,直接给true
     */
   /* public boolean equals(Object obj){
        if (this==obj){
            return true;
        }

        if (obj==null){
            return false;
        }

        if (obj instanceof Person){
            Person p = (Person) obj;
            return this.name.equals(p.name)&&this.age==p.age;
        }
        return false;

    }*/

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
public class Test03 {
    public static void main(String[] args) throws CloneNotSupportedException {
        Person p2 = new Person("涛哥", 16);
        Object o = p2.clone();
        Person p3 = (Person) o;//克隆了一个新对象

        System.out.println(p2==p3);//比较地址值  false
        System.out.println(p2.equals(p3));//true
    }
}

```

# 第四章.经典接口

## 1.java.lang.Comparable

我们知道基本数据类型的数据（除boolean类型外）需要比较大小的话，之间使用比较运算符即可，但是引用数据类型是不能直接使用比较运算符来比较大小的。那么，如何解决这个问题呢？

Java给所有引用数据类型的大小比较，指定了一个标准接口，就是java.lang.Comparable接口：

```java
package java.lang;

public interface Comparable{
    int compareTo(Object obj);
}
```

那么我们想要使得我们某个类的对象可以比较大小，怎么做呢？步骤：

第一步：哪个类的对象要比较大小，哪个类就实现java.lang.Comparable接口，并重写方法

* 方法体就是你要如何比较当前对象和指定的另一个对象的大小

第二步：对象比较大小时，通过对象调用compareTo方法，根据方法的返回值决定谁大谁小。

* this对象（调用compareTo方法的对象）减 指定对象（传入compareTo()的参数对象）大于0,返回正整数
* this对象（调用compareTo方法的对象）减 指定对象（传入compareTo()的参数对象）小于0 返回负整数
* this对象（调用compareTo方法的对象）减 指定对象（传入compareTo()的参数对象）等于0 返回零

代码示例：

```java
public class Student implements Comparable{
    private String name;
    private int score;

    public Student() {

    }

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", score=" + score +
                '}';
    }

    /*
      this:代表students[i]
      o:代表students[i+1]

      如果students[i].getScore()-students[i+1].getScore()>0
         证明数组中的前面一个对象比后面一个对象的分数高
     */
    @Override
    public int compareTo(Object o) {
        Student s = (Student) o;
        return this.getScore()- s.getScore();
    }
}
```

测试类

```java
public class Test01 {
    public static void main(String[] args) {
        //创建一个数组
        Student[] students = new Student[3];
        Student s1 = new Student("张三", 100);
        Student s2 = new Student("李四", 60);
        Student s3 = new Student("王五", 80);
        students[0] = s1;
        students[1] = s2;
        students[2] = s3;

        for (int j = 0; j<students.length-1;j++){
            for (int i = 0;i<students.length-1-j;i++){
                //如果students[i]比students[i+1]大,就排序换位置
                if (students[i].compareTo(students[i+1])>0){
                    Student temp = students[i];
                    students[i] = students[i+1];
                    students[i+1] = temp;
                }
            }
        }

        //遍历
        for (int i = 0; i < students.length; i++) {
            System.out.println(students[i]);
        }
    }
}

```

## 2.java.util.Comparator

思考：

（1）如果一个类，没有实现Comparable接口，而这个类你又不方便修改（例如：一些第三方的类，你只有.class文件，没有源文件），那么这样类的对象也要比较大小怎么办？

（2）如果一个类，实现了Comparable接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？

JDK在设计类库之初，也考虑到这种情况了，所以又增加了一个java.util.Comparator接口。

```java
package java.util;

public interface Comparator{
    int compare(Object o1,Object o2);
}
```

那么我们想要比较某个类的两个对象的大小，怎么做呢？步骤：

第一步：编写一个类，我们称之为比较器类型，实现java.util.Comparator接口，并重写方法

* 方法体就是你要如何指定的两个对象的大小

第二步：比较大小时，通过比较器类型的对象调用compare()方法，将要比较大小的两个对象作为compare方法的实参传入，根据方法的返回值决定谁大谁小。

* o1对象减o2大于0返回正整数
* o1对象减o2小于0返回负整数
* o1对象减o2等于0返回零

```java
public class Student implements Comparator {
    private String name;
    private int score;

    public Student() {

    }

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", score=" + score +
                '}';
    }


    /*
       o1代表students[i]
       o2代表students[i+1]

       如果o1的分数大于o2的分数-> compare方法返回正整数
       如果o1的分数小于o2的分数-> compare方法返回负整数
       如果o1的分数等于o2的分数-> compare方法返回0
     */
    @Override
    public int compare(Object o1, Object o2) {
        Student s1 = (Student) o1;
        Student s2 = (Student) o2;
        return s1.getScore()-s2.getScore();
    }

}

```

```java
public class Test01 {
    public static void main(String[] args) {
        //创建一个数组
        Student[] students = new Student[3];
        Student s1 = new Student("张三", 100);
        Student s2 = new Student("李四", 60);
        Student s3 = new Student("王五", 80);
        students[0] = s1;
        students[1] = s2;
        students[2] = s3;

        Student student = new Student();

        for (int j = 0; j<students.length-1;j++){
            for (int i = 0;i<students.length-1-j;i++){
                //如果students[i]比students[i+1]大,就排序换位置
                if (student.compare(students[i],students[i+1])>0){
                    Student temp = students[i];
                    students[i] = students[i+1];
                    students[i+1] = temp;
                }
            }
        }

        //遍历
        for (int i = 0; i < students.length; i++) {
            System.out.println(students[i]);
        }
    }
}

```



# 第09章_异常处理

## 1. 异常概述

### 1.1 什么是生活中的异常

### 1.2 什么是程序的异常

在使用计算机语言进行项目开发的过程中，即使程序员把代码写得`尽善尽美`，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：`客户输入格式的问题`、`读取文件是否存在`、`网络是否始终保持畅通`等等

- <font color="#c43c3c">**异常**</font>：指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止

> 异常指的不是语法错误和逻辑错误。语法错了，编译不通过，不会产生字节码文件，根本不能运行。
>
> 代码逻辑错误，只是没有得到想要的结果，例如：求a与b的和，写成了a-b

### 1.3 异常的抛出机制

Java中是如何表示不同的异常情况，优势如何让程序员得知，并处理异常的呢？

Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出(throw)，然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。

举例：

运行下面的程序，程序会产生一个数组角标越界异常`ArrayIndexOutOfBoundsException`。我们通过图解来解析异常产生和抛出的过程。

```java
public class ArrayTools {
    public static int getElement(int[] arr, int index){
        int element = arr[index];
            return element;
    }
}
```

测试类

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        int[] arr = {34, 12, 67};
        intumn = ArrayTools.getElement(arr, 4);
        System.out.println("num=" + num);
        System.out.println("over")
    }
}
```

上述程序执行过程图解：

![1729937106198](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729937106198.png)

### 1.4 如何对待异常

对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及`异常的处理`，保证代码的`健壮性`

## 2. Java异常体系

### 2.1 Throwable

`java.lang.Throwable`类是Java程序执行过程中发生的异常事件对应的类的根父类

<font color="#c43c3c">**Throwable中的常用方法：**</font>

- `pubilc void printStackTrace()`：打印异常的详细信息。

  包含了异常的类型、异常的原因、异常出现的位置、在开发和调试截断都得使用printStackTrace

- `public String getMessage()`：获取异常发生的原因

### 2.2 Error和Exception

Throwable可以分为两类：Error和Exception。分别对应着`java.lang.Error`和`java.lang.Exception`两个类

<font color="#c43c3c">**Error**</font>：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理

- 例如：StackOverFlowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。

  ```java
  public class ErrorTest {
      public static void main(String[] args) {
  
          //举例1：栈内存溢出的错误StackOverflowError
          main(args);
  
          //举例2：堆空间溢出OutOfMemory：Java heap space
          byte[] arr = new byte[1024*1024*100];
      }
  }
  ```

  

<font color="#c43c3c">**Exception**</font>：其他因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行，否则一旦发生异常，程序也会挂掉。例如：

- 空指针访问
- 试图读取不存在的文件
- 网络连接中断
- 数组角标越界

### 2.3 编译时异常和运行时异常

Java程序的执行分为编译时异常和运行时异常，有的错误只有在`运行时`才会发生。比如：除数为0，数组下标越界等。

![1729993712486](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729993712486.png)

因此，根据异常可能出现的阶段，可以将异常分为：

- <font color='c43c3c'>**编译时期异常**</font>（即checked异常、受检异常）：在代码编译阶段，编译器就能明确`警示`当前代码`可能发生（不是一定发生）`xx异常，并`明确督促`程序员提前编写处理它的代码。如果程序员`没有编写`对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠简单判断就可以避免的，例如：FileNotFoundException（文件找不到异常）
- <font color='c43c3c'>**运行时期异常**</font>（即runtime异常、unchecked异常、非受检异常）：在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了xx异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免。
  - <font color='c43c3c'>**java.lang.RuntimeException**</font>类以及它的子类都是运行时异常。比如：ArrayIndexOutOfBoundsException数组下标越界异常，ClassCastException类型转换异常。

> java.lang.Throwable:异常体系的根父类    
>
> |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况. 一般不编写针对性的代码进行处理                			
>
> ​			|--- StackOverFlowError、OutOfMemoryError    
>
> |---java.lang.Exception:异常。我们可以1编写针对性的代码进行处理。                
>
> ​			|---编译时异常(受检异常)：在执行javac.exe命令时，出现的异常                    
>
> ​						|--- ClassNotFoundException                    
>
> ​						|--- FileNotFoundException                   	
>
> ​						|--- IOException                	
>
> ​			|---运行时异常(非受检异常)：在执行java.exe命令时，出现的异常                    
>
> ​						|---ArrayIndexOutOfBoundsException                    
>
> ​						|---NullPointerException                    
>
> ​						|---ClassCastException                    
>
> ​						|---NumberFormatException                    
>
> ​						|---InputMismatchException                    
>
> ​						|---ArithmeticException

## 3. 常见的错误和异常

### 3.1 Error

- StackOverflowError
- OutOfMemoryError

### 3.2 运行时异常

- ArrayIndexOutOfBoundsException
- NullPointerException
- ClassCastException
- NumberFormatException
- InputMismatchException
- ArithmeticException

### 3.3 编译时异常

- ClassNotFoundException
- FileNotFoundException
- IOException

## 4. 异常的处理

### 4.1 异常处理概述

在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要`检验分母为0`，`数据为空`，`输入的不是数据而是字符`等。过多的if-else分支会导致程序的`代码加长`、`臃肿`、`可读性差`，程序员需要花费很大的精力`堵漏洞`。因此采用异常处理机制。

<font color="#c43c3c">**Java异常处理**</font>

Java采用的异常处理机制，是`将异常处理的程序代码集中在一起`，与正常的程序代码分开，使得程序简洁、优雅，并易于维护

<font color="#c43c3c">**Java异常处理的方式：**</font>

方式一：try-catch-finally

方式二：throws + 异常类型

### 4.2 方式1：捕获异常(try-catch-finally)

Java提供了异常处理的<font color="#c43c3c">**抓抛模型**</font>

- 前面提到，Java程序的执行过程中如出现异常，就会在出现异常的代码处生成对应异常类的对象，该异常对象将被提交给Java运行时系统，一旦抛出，此程序就不执行其后的代码了。这个过程称为`抛出（throw）异常`。
- 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用者的上层方法。这个过程将一直延续下去，知道异常被处理。这一过程称为`捕获（catch）异常`

#### 4.2.1 try-catch-finally基本格式

捕获异常语法如下：

```java
try{
    ......   //可能产生异常的代码
}
catch( 异常类型1 e){
    ......   //当产生异常类型1型异常时的处置措施
}
catch( 异常类型2 e){
    ......   //当产生异常类型2型异常时的处置措施
}
finally{
    ......   //无论是否发生异常，都无条件执行的语句
}
```

<font color="#c43c3c">**1、整体执行过程：**</font>

当某段代码可能发生异常，不管这个异常是编译时异常（受检异常）还是运行时异常（非受检异常），我们都可以使用try块将其括起来，并在try块下面编写catch分支尝试捕获对应的异常对象。



- 使用细节：
  - 将可能出现异常的代码声明在try语句中。一旦代码出现异常，就会自动生成一个对应异常类的对象，并将此对象抛出。
  - 针对于try中抛出的异常类对象，使用之后的catch语句进行匹配。一旦匹配上，就进入catch语句块进行处理。一旦处理结束，代码就可继续向下执行。
  - 如果声明了多个catch结构，不同的异常类型在不存在子父类关系的情况下，谁声明在上面，谁声明在下面都可以。如果多个异常类型满足子父类关系，则必须将子类声明在父类结构的上面。否则报错
  - catch中异常处理的方式：
    - 自己编写输出的语句。
    - `printStackTrace()`：打印异常的详细信息。
    - `getMessage()`：获取异常发生的原因
  - try中声明的变量，出了try结构后，就不可以再调用（作用域）
  - try-catch结构是可以嵌套使用的。

#### 4.2.2 使用举例

```java
//运行时异常
public class ExceptionHandleTest {
    @Test
    public void test1(){
        try {
            Scanner scanner = new Scanner(System.in);
            int num = scanner.nextInt();
            System.out.println(num);
            scanner.close();

        } catch (InputMismatchException e) {
            System.out.println("出现了InputMismatchException的异常");
        }catch (NullPointerException e){
            System.out.println("出现了NullPointerException的异常");
        }catch (RuntimeException e){    //这是上两个的父类，要写他们的下面，否则报错
            System.out.println("出现了RuntimeException的异常");
        }

        System.out.println("异常处理结束，代码继续执行...");
    }

    @Test
    public void test2(){
        try {
            String str = "123";
            str = "abc";
            int i = Integer.parseInt(str);
            System.out.println(i);
        } catch (NumberFormatException e) {
            e.printStackTrace();  //输出的结果看起来和处理之前一样，但处理前程序出问题了没过，处理完能过
            System.out.println(e.getMessage());
        }
        System.out.println("程序结束");
    }
}
```

```java
//编译时异常
public class ExceptionHandleTest {
    @Test
    public void test3(){
        try {
            File file = new File("D:/hello.txt");

            FileInputStream fis = new FileInputStream(file);

            int data = fis.read();
            while (data != -1){
                System.out.print((char) data);
                data = fis.read();
            }

            fis.close();
        }catch (FileNotFoundException e) {
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();    //其实留这个就行，这个是上面的父类
        }

        System.out.println("读取数据结束");
    }
}
```

- 开发体会：
  - 对于运行时异常：开发中通常不进行显式的处理了。一旦在程序执行中出现了运行时异常，那么就根据一擦汗给你的提示信息修改代码即可。
  - 对于编译时异常：一定要进行处理，否则编译不通过。

#### 4.2.3 finally使用及举例

- 因为异常会引发程序跳转（从出现异常的语句直接跳转到对应的捕捉异常类），从而会导致有些语句执行不到。而程序中有一些特定的代码无论异常是否发生，都`需要执行`。例如，数据库连接、输入流输出流、Socket连接、Lock锁的关闭等，这样的代码通常就会放到finally块中。所以，我们通常将一定要被执行的代码声明在finally中。
  - 唯一的例外，使用<font color="#c43c3c">System.exit(0)来终止</font>当前正在运行的Java虚拟机
- 不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。
- finally语句和catch语句是可选的，但`finally不能单独使用。`

- finally的理解：
  - 我们将一定要被执行的代码声明在finally结构中。
  - 更深刻的理解：无论try中或catch中是否存在未被处理的异常，无论try中或是catch中是否存在return语句等，finally中声明的语句都一定要被执行
- 需要在finally中声明的代码：
  - 我们在开发中，有一些资源（比如：输入流、输出流、数据库连接、Socket连接等资源），在使用完以后，必须显式地进行关闭操作，否则，GC不会自动地回收这些资源，进而导致`内存泄漏`。为了保证这些资源在使用完以后，不管是否出现了未被处理的异常的情况，这些资源都能被关闭，我们必须将这些操作声明在finally中！

```java
@Test
    public void test3(){
        FileInputStream fis = null;  
        //需要在catch和finally中使用的变量放在try代码块外面声明
        try {
            File file = new File("D:/hello.txt");

            fis = new FileInputStream(file);

            int data = fis.read();
            while (data != -1){
                System.out.print((char) data);
                data = fis.read();
            }

        }catch (FileNotFoundException e) {
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();    //其实留这个就行，这个是上面的父类
        }finally {
            //重点：将流资源的关闭操作声明在finally中
            try {
                fis.close();
            } catch (IOException e){
                e.printStackTrace();
            }
            
        }

        System.out.println("读取数据结束");
    }
```



```java
public class FinallyTest1 {
    public static void main(String[] args) {
        int result = test("12");
        System.out.println(result);
    }
    public static int test(String str){
        try {
            Integer.parseInt(str);
            return 1;
        } catch (NumberFormatException e){
            return -1;
        } finally {
            System.out.println("test结束");   
            //若去掉finally，会报错因为这条语句无法到达
        }
    }
}
//结果：
test结束
1
```

```java
public class FinallyTest2 {
    public static void main(String[] args) {
        int result = test("a");
        System.out.println(result);
    }
    public static int test(String str){
        try {
            Integer.parseInt(str);
            return 1;
        } catch (NumberFormatException e){
            return -1;
        } finally {
            System.out.println("test结束");
            //若去掉finally，会报错因为这条语句无法到达
        }
    }
}
//结果：
test结束
-1
```

```java
public class FinallyTest3 {
    public static void main(String[] args) {
        int result = test("a");
        System.out.println(result);
    }
    public static int test(String str){
        try {
            Integer.parseInt(str);
            return 1;
        } catch (NumberFormatException e){
            return -1;
            //在return之前，先到finally，因此最后是finally中的return
        } finally {
            System.out.println("test结束");
            //若去掉finally，会报错因为这条语句无法到达
            return 0;
        }
    }
}
//结果：
test结束
0
```

```java
public class FinallyTest4 {
    public static void main(String[] args) {
        int result = test(10);
        System.out.println(result);
    }
    public static int test(int num){
        try {
            return num;
        } catch (NumberFormatException e){
            return num--;
            //在return之前，先到finally，因此最后是finally中的return
        } finally {
            System.out.println("test结束");
            //若去掉finally，会报错因为这条语句无法到达
            return ++num;
        }
    }
}
//结果：
test结束
11
```

```java
public class FinallyTest4 {
    public static void main(String[] args) {
        int result = test(10);
        System.out.println(result);
    }
    public static int test(int num){
        try {
            return num;
        } catch (NumberFormatException e){
            return num--;
            //在return之前，先到finally，因此最后是finally中的return
        } finally {
            System.out.println("test结束");
            //若去掉finally，会报错因为这条语句无法到达
            ++num;
            
        }
    }
}
//结果：
test结束
10
```

![1730033814207](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1730033814207.png)

#### 4.2.4 final、finally、finalize的区别



### 4.3 方式2：throws

#### 4.3.1 throws + 异常类型 基本格式

```java
public void test() throws 异常类型1,异常类型2,... {
    //可能存在编译时异常
}
```

#### 4.3.2 使用举例

```java
public class ThrowsTest {
    public void method1() throws FileNotFoundException, IOException {
        File file = new File("hello.txt");
        FileInputStream fis = new FileInputStream(file);  //可能报FileNotFoundException
        int data = fis.read();
        while (data != -1){
            System.out.println((char) data);
            data = fis.read();                            //可能报IOException
        }
        fis.close();
    }
}
```

```java
public class ThrowsTest {
    //不要在main方法中使用throws，因为已经到头了只能抛给java虚拟机了
    public static void main(String[] args) {
        method3();
    }

    public static void method3(){
        try {
            method2();
        } catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void method2() throws FileNotFoundException,IOException {
        method1();
    }

    public static void method1() throws FileNotFoundException, IOException {
        File file = new File("hello.txt");
        FileInputStream fis = new FileInputStream(file);  //可能报FileNotFoundException
        int data = fis.read();
        while (data != -1){
            System.out.println((char) data);
            data = fis.read();                            //可能报IOException
        }
        fis.close();
    }
}
//throws只是抛出，没有处理，因此调用了可能出现的异常的方法的方法要么抛给上层方法，要么处理异常，当到main方法时不能再抛出异常了
```

#### 4.3.3 是否真正处理了异常

- 从编译是否能通过的角度看：看成是给出了异常万一要是出现了的时候的解决方案。此方案就是，继续向上抛出（throws）
- 但是，此throws的方式，仅是将可能出现的异常抛给了该方法的调用者，此调用者仍需要考虑如何处理相关异常。从这个角度看，throws的方式不算是真正意义上处理了异常

#### 4.3.4 方法重写的要求

子类重写的方法可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类

那么，根据上面的规则，父类的方法没有抛出异常时，子类重写父类的对应方法也不能抛出异常

上述规则只针对编译时异常

```java
public class OverrideTest {
    public static void main(String[] args) {
        Father f = new son();

        try {
            f.method1();
        //编译在左，看父类，真正运行的时候这个异常类必须包括子类的异常类
        } catch (IOException e){
            e.printStackTrace();
        }
    }
}

class Father{
    public void method1() throws IOException {

    }

    public void method2(){

    }
    
    public void method3(){
        
    }
}

class son extends Father{
    public void method1() throws FileNotFoundException {

    }

    public void method2(){

    }
    
    public void method3() throws RuntimeException{
        
    }
}
```

### 4.4 两种异常处理方式的选择

前提：对于异常，使用相应的处理方式。此时的异常，主要是指编译时异常

- 如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏
- 如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑用try-catch-finally进行处理，不能throws
- 开发中，方法a中一次调用了方法b、c、d等方法，方法b、c、d之间是递进关系，此时，如果方法b、c、d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally



## 5. 手动抛出异常对象：throw

Java中异常对象的生成有两种方式：

- 由虚拟机<font color="#c43c3c">**自动生成**</font>：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。
- 由开发人员<font color="#c43c3c">**手动创建**</font>：`new 异常类型([实参列表]);`，如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是，一旦由throw抛出，就会对程序运行产生影响了。

为什么需要手动抛出异常对象？

在实际开发中，如果出现不满足具体场景的代码问题，我们就有必要手动抛出一个指定类型的异常对象。

如何理解“自动 vs 手动”抛出异常对象？

- 过程1：“抛”
  - "自动抛"：程序在执行过程中，一旦出现异常，就会在出现异常的代码处，自动生成对应异常类的对象，并将此对象抛出
  - “手动抛”：程序在执行过程当中，不满足指定条件的情况下，主动地使用“throw + 异常类的对象”方式抛出异常对象
- 过程2：“抓”
  - 狭义上：try-catch-finally的方式捕获异常，并处理
  - 广义上：把“抓”理解为处理，则此时对应着异常处理的两种方式：
    - try-catch-finally
    - throws

### 5.1 使用格式

`throw new 异常类型([实参列表]);`

```java
public class ThrowTest {
    public static void main(String[] args) {
        Student s1 = new Student();
        try {
            s1.register(10);
            s1.register(-10);
            System.out.println(s1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Student{
    int id;
//    public void register(int id){
//        if (id > 0 ){
//            this.id = id;
//        }else {
////            System.out.println("输入的id非法");
//            throw new RuntimeException("输入的id非法");
//        }
//    }

    public void register(int id) throws Exception{
        if (id > 0 ){
            this.id = id;
        }else {
//            System.out.println("输入的id非法");
            throw new Exception("输入的id非法");
        }
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                '}';
    }
}
```



### 5.2 使用注意点

- throw后的代码不能被执行，编译不通过





### 5.3 throw和throws的区别

- 使用形式上：throws使用在方法的声明处，指明了把产生的异常对象继续向上一层抛出，属于异常处理的一种方式；throw是使用在方法内部，后面跟着异常类的对象，表示手动地抛出一个指定的异常类的对象
- 使用场景/解决问题上：throw是用来产生异常对象的，throws是针对于产生的异常类对象如何去处理的



### 5.4 自定义异常类

#### 5.4.1 基本格式

- 继承于现有的异常T恤。通常继承于RuntimeException \ Exception
- 通常提供几个重载的构造器
- 提供一个全局常量，声明为：static final long serialVersionUID;

```java
public class BelowZeroException extends Exception{
    static final long serialVersionUID = -3387516999948L;
    public BelowZeroException(){

    }
    public BelowZeroException(String name){
        super(name);
    }

    public BelowZeroException(String message, Throwable cause){
        super(message, cause);
    }
}
```

#### 5.4.2 使用举例

在具体的代码中，满足指定条件的情况下，需要手动地使用“throw + 自定义异常类的对象”的方式，将异常对象抛出

如果自定义异常类是非运行时异常，则必须考虑如何处理此异常类的对象。（具体地，① try-catch-finally ② throws）

```java
public class ThrowTest {
    public static void main(String[] args) {
        Student s1 = new Student();
        try {
            s1.register(10);
            s1.register(-10);
            System.out.println(s1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Student{
    int id;
//    public void register(int id){
//        if (id > 0 ){
//            this.id = id;
//        }else {
////            System.out.println("输入的id非法");
//            throw new RuntimeException("输入的id非法");
//        }
//    }

    public void register(int id) throws Exception{
        if (id > 0 ){
            this.id = id;
        }else {
//            System.out.println("输入的id非法");
//            throw new Exception("输入的id非法");
            throw new BelowZeroException("输入的id非法");
        }
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                '}';
    }
}
//结果：
com.chen04._throw.BelowZeroException: 输入的id非法
	at com.chen04._throw.Student.register(ThrowTest.java:42)
	at com.chen04._throw.ThrowTest.main(ThrowTest.java:17)
```

#### 5.4.3 为什么需要自定义异常类

我们其实更关心的是，通过异常的名称就能直接判断此异常出现的原因。既然如此，我们就有必要在实际开发场景中，不满足我们指定的条件时，指明我们自己特有的异常类。通过此异常类的名称，就能判断出具体出现的问题。