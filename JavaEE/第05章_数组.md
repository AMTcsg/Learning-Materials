# 第04章_数组

## 1. 数组的概述

### 1.1 为什么需要数组

### 1.2 数组的概念

- 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行同一管理。
- 数组中的概念
  - 数组名
  - 下标(索引index)
  - 元素
  - 数组的长度

Java中的容器：数组、集合框架：在<font color="#FF9900">内存</font>中对多个数据的存储。

<font color="#c43c3c">**数组的特点：**</font>

- 数组本身是<font color="#FF9900">引用数据类型</font>，而数组中的元素可以是<font color="#FF9900">任何数据类型</font>，包括基本数据类型和引用数据类型。
- 创建数组对象会在内存中开辟一整块<font color="#FF9900">连续的空间</font>。占据的空间的大小，取决于数组的长度和数组中元素的类型。
- 数组中的元素在<font color="#FF9900">内存中依次紧密排列、有序</font>
- 数组，一旦初始化完成，其长度就是确定的。数组的<font color="#FF9900">长度一旦确定，就不能修改</font>
- 可以直接通过下标/索引的方式调用指定位置的元素，速度很快
- 数组名中引用的是<font color="#FF9900">`这块连续空间的首地址`</font>

### 1.3 数组的分类

<font color="#c43c3c">**1、按照元素的类型：**</font>

- 基本数据类型元素的数组：每个元素位置存储基本数据类型的值
- 引用数据类型元素的数组：每个元素位置存储对象(<font color="#FF9900">本质是存储对象的首地址</font>)

<font color="#c43c3c">**2、按照维度：**</font>

一维、二维、……

## 2. 一维数组的使用

### 2.1 一维数组的声明

`数据类型[] 数组名;`

### 2.2 一维数组的初始化

#### 2.2.1 静态初始化

数组变量的初始化与数组元素的赋值操作同时进行

```java
prices = new double[]{20.32, 43.21, 43.22};

//声明+初始化
int[] arr1 = new int[]{1, 2, 3, 4}; 

int[] arr2 = {1, 2, 3, 4};  
```

#### 2.2.2 动态初始化

数组变量的初始化与数组元素的赋值操作分开进行

```java
//声明+初始化
String[] foods = new String[4];

int arr[] = new int[4];
```

### 2.3 一维数组的使用

#### 2.3.1 数组的长度

用来描述数组容器中容量的大小

```java
//3.数组的长度：用来描述数组容量大小
//使用length属性表示
System.out.println(foods.length);
System.out.println(prices.length);
```

#### 2.3.2 数组元素的引用

规则：通过角标的方式获取数组的元素

> **说明：下标的范围从0开始，到数组的长度-1结束**

```java
//2.数组元素的调用
//通过角标的方式获取数组的元素（从0开始）System.out.println(prices[0]);
System.out.println(prices[2]);

foods[0] = "拌海蜇";
foods[1] = "龙须菜";
foods[2] = "炝冬笋";
foods[3] = "玉兰片";
//foods[4] = "酱茄子"; //报异常：ArrayIndexOutOfBoundsException
```

### 2.4 一维数组的遍历

```java
for(int i = 0;i < foods.length;i++){
    System.out.println(foods[i]);
}
```

### 2.5 数组元素的默认值

- 整型元素数组的默认初始化值：0
- 浮点型元素数组的默认初始化值：0.0
- 字符型元素数组的默认初始化值：0/"\u0000"
- boolean型元素数组的默认初始化值：false
- 引用数据类型元素数组的默认初始化值：null

```java
public class OneArrayTest1 {
    public static void main(String[] args) {
        //5.数组元素的默认初始化值
        int[] arr1 = new int[3];
        System.out.println(arr1[0]);      //0

        short[] arr2 = new short[4];
        System.out.println(arr2[0]);      //0

        double[] arr3 = new double[3];
        System.out.println(arr3[0]);      //0.0

        char[] arr4 = new char[4];
        System.out.println(arr4[0]);      //0/"\u0000" 

        boolean[] arr5 = new boolean[1];
        System.out.println(arr5[0]);      //false

        String[] arr6 = new String[2];
        for (int i=0;i < arr6.length;i++){
            System.out.println(arr6[i]);  //null null
        }

    }
}
```

### 2.6 练习

```java
public class ArrayExer {
    public static void main(String[] args) {
        int[] arr = new int[]{8, 2, 1, 0, 3};
        int[] index = new int[]{2, 0, 3, 2, 4, 0, 1, 3, 2, 3, 3};

        String tel = "";

        for (int i = 0; i < index.length; i++){
            int value = index[i];
            tel += arr[value];
        }
        System.out.println("联系方式：" + tel);
    }
}
```

```java
public class ArrayExer2 {
    public static void main(String[] args) {
        //定义包含7个单词的数组
        String[] weekdays = new String[]{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};

        //从键盘获得指定的数值
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入数值(1-7)：");
        int day = scan.nextInt();

        if(day > 7 || day < 1){
            System.out.println("你输入的数据有误。");
        }else{
            System.out.println(weekdays[day - 1]);
        }
        scan.close();
    }
}
```

```java
public class ArrayExer3 {
    public static void main(String[] args) {
        //1. 从键盘输入学生的人数，根据人数，创建数组(动态初始化)
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入学生人数：");
        int count = scan.nextInt();

        int[] scores = new int[count];

        //2. 根据提示，依次输入学生成绩，并将成绩保存在数组元素中
        System.out.println("请输入" + count + "名学生的成绩");
        for (int i = 0; i < scores.length; i++){
            scores[i] = scan.nextInt();
        }
        //3. 获取学生成绩的最大值
        int maxScore = scores[0];
        for (int i = 1; i < scores.length; i++){
            if(maxScore < scores[i]){
                maxScore = scores[i];
            }
        }
        System.out.println("最高分是：" + maxScore);
        //4. 遍历数组元素，根据学生成绩与最高分的差值，得到每个学生的等级，并输出成绩和等级
        for (int i = 0;i < scores.length; i++){
            if(scores[i] >= maxScore - 10){
                System.out.println("student" + i + " score is " + scores[i] + " grade is A");
            }else if (scores[i] >= maxScore - 20){
                System.out.println("student" + i + " score is " + scores[i] + " grade is B");
            }else if (scores[i] >= maxScore - 30){
                System.out.println("student" + i + " score is " + scores[i] + " grade is C");
            }else{
                System.out.println("student" + i + " score is " + scores[i] + " grade is D");
            }
        }
    }
}

//另一种写法：
public class ArrayExer3_1 {
    public static void main(String[] args) {
        //1. 从键盘输入学生的人数，根据人数，创建数组(动态初始化)
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入学生人数：");
        int count = scan.nextInt();

        int[] scores = new int[count];

        //2. 根据提示，依次输入学生成绩，并将成绩保存在数组元素中
        int maxScore = scores[0];
        System.out.println("请输入" + count + "名学生的成绩");
        for (int i = 0; i < scores.length; i++){
            scores[i] = scan.nextInt();
            //3. 获取学生成绩的最大值
            if(maxScore < scores[i]) {
                maxScore = scores[i];
            }
        }
        System.out.println("最高分是：" + maxScore);

        //4. 遍历数组元素，根据学生成绩与最高分的差值，得到每个学生的等级，并输出成绩和等级
        char grade;
        for (int i = 0;i < scores.length; i++) {
            if (scores[i] >= maxScore - 10) {
                grade = 'A';
            } else if (scores[i] >= maxScore - 20) {
                grade = 'B';
            } else if (scores[i] >= maxScore - 30) {
                grade = 'C';
            } else {
                grade = 'D';
            }
            System.out.println("student" + i + " score is " + scores[i] + " grade is " + grade);
        }
    }
}
```



## 3. 一维数组内存分析

### 3.1 Java虚拟机的内存划分

为了提高运行效率，Java虚拟机对空间进行了5不同区域的划分，因为每一片区域都有特定的数据处理方式和内存管理方式。

![1729070699388](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729070699388.png)

| 区域名称                              | 作用                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| <font color="#FF9900">虚拟机栈</font> | 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译器可知长度的各种基本数据类型、对象引用，方法执行完，自动释放 |
| <font color="#FF9900">堆内存</font>   | 存储对象(包括数组对象)，new来创建的，都存储在堆内存          |
| <font color="#FF9900">方法区</font>   | 存储已被虚拟机加载的类信息、常量、(静态变量)、即时编译器编译后的代码等数据 |
| 本地方法栈                            | 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 |
| 程序计数器                            | 程序计数器时CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址 |

与目前数组相关的内存结构：   比如：`int[] arr = new int[]{1,2,3}`

- 虚拟机栈：用于存放方法(包括main)中声明的局部变量。比如：arr
- 堆：用于存放数组的实体(即数组中的所有元素)。比如：1,2,3

### 3.3 一维数组在内存中的存储

#### 3.3.1 一个一维数组内存图

下面的情况中已包含

#### 3.3.2 数组下标为什么从0开始

数组的下标刻画的是偏移量，除了下标为0的元素的地址与数组名对应的地址相同，其他元素的地址不进行暴露，所以下标实际刻画的是地址的偏移量，数组元素得通过下标才能访问到地址

#### 3.3.3 两个一维数组内存图

![1729073299465](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729073299465.png)

#### 3.3.4 两个变量指向一个一维数组

![1729074313222](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729074313222.png)

## 4. 二维数组的使用

### 4.1 概述

- Java语言中提供了支持多为数组的语法

- 二维数组相当于是一个表格，像Excel中的表格、围棋棋盘一样。

- <font color="#c43c3c">**应用举例：**</font>

  某公司对2022年全年各个月份的销售额进行登记。按月份存储，可以使用一维数组。

  ```java
  int[] monthData = new int[]{23,43,22,34,55,65,44,67,45,78,67,66};
  ```

  如果改写为按季度为单位存储怎么办？

  ```java
  int[][] quarterData = new int[]{{23,43,22},{34,55,65},{44,67,45},{78,67,66}};
  ```

- 使用说明

  ![1729076162435](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729076162435.png)

  > - 对于二维数组的理解，可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。
  > - 其实，从数组底层的运行机制来看，其实没有多维数组。
  > - 概念：数组的外层元素；数组的内层元素

### 4.2 二维数组声明与初始化

#### 4.2.1 声明

二维数组声明的语法格式：

`数据类型[][] 变量名;`

#### 4.2.2 静态初始化

```java
int[][] arr1 = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8 ,9}};
```

#### 4.2.3 动态初始化

```java
//动态初始化1
String[][] arr2 = new String[3][4];
//动态初始化2
double[][] arr3 = new double[2][];
```

其他正确的写法：

```java
//其他正确的写法：
int arr4[][] = new int[][]{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};
int[] arr5[] = new int[][]{{1, 2, 3}, {4, 5}, {6, 7 ,8, 9}};
int arr6[][] = {{1, 2, 3}, {4, 5}, {6, 7, 8, 9}}; //类型推断
String arr7[][] = new String[3][4];
```

### 4.3 二维数组的长度

用来描述数组容器中容量的大小

```java
int arr4[][] = new int[][]{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};
//3. 数组的长度
System.out.println(arr4.length);         //3
System.out.println(arr4[1].length);      //2
```

### 4.4 二维数组元素的引用

规则：通过角标的方式获取数组的元素

> **说明：下标的范围从0开始，到数组的长度-1结束**

```java
int[][] arr1 = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8 ,9}};
String[][] arr2 = new String[3][4];

//2. 数组元素的调用
//调用内层元素
System.out.println(arr1[0][0]);    //1
System.out.println(arr1[2][1]);    //7

//调用外层元素
System.out.println(arr1[0]);       //[I@b4c966a返回地址值

//测试arr2,arr3
arr2[0][1] = "Tom";
System.out.println(arr2[0][1]);
System.out.println(arr2[0]); //[Ljava.lang.String;@2f4d3709

arr3[0] = new double[4];
arr3[0][0] = 1.0;
```

### 4.5 二维数组的遍历

```java
//4. 如何遍历数组
for (int i = 0; i < arr4.length; i++){
    for (int j = 0 ; j < arr4[i].length; j++){
        System.out.print(arr4[i][j] + "\t");
    }
    System.out.println();
}
```

### 4.6 二维数组元素的默认初始化值

- 动态初始化方式1：
  - 外层元素：默认存储地址值
  - 内层元素：默认与一维数组元素的对应类型的默认值相同
- 动态初始化方式2：
  - 外层元素：null（只定义了外层数组，内层未定义，不知道要开辟多少内存，因此没有开辟空间，没有指向地址值，而数组是引用数据类型，因此默认值为null）
  - 内层元素：没有指针，会报空指针异常(NullPointerException)

```java
//5. 数组元素的初始化值
        //以动态初始化方式1说明：
        int[][] arr1 = new int[3][2];
        //外层元素默认值：
        System.out.println(arr1[0]);            //地址值
        System.out.println(arr1[1]);            //地址值
        //内层元素默认值：
        System.out.println(arr1[0][0]);         //0

        boolean[][] arr2 = new boolean[3][4];
        System.out.println(arr2[0]);            //地址值
        System.out.println(arr2[0][1]);         //false

        String[][] arr3 = new String[4][2];
        System.out.println(arr3[0]);            //地址值
        System.out.println(arr3[0][1]);         //null

        //**********************************************
        //以动态初始化方式2说明：
        int[][] arr4 = new int[4][];
        System.out.println(arr4[0]);            //null
        //System.out.println(arr4[0][0]);         //报错：空指针异常(NullPointerException)
```

### 4.7 二维数组的内存解析

![1729078630273](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729078630273.png)

示例1：

![1729080020633](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729080020633.png)

示例2：

![1729080941309](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\1729080941309.png)

### 4.8 练习

```java
public class ArrayExer01 {
    public static void main(String[] args) {
        int[][] arr = new int[][]{{3, 5, 8}, {12, 9}, {7, 0, 6, 4}};
        int sum = 0;
        for (int i = 0; i < arr.length; i++){
            for (int j = 0; j < arr[i].length; j++){
                sum += arr[i][j];
            }
        }
        System.out.println(sum);
    }
}
```

```java
public class ArrayExer02 {
    public static void main(String[] args) {
        //数组赋值
        //总结：数组之间要能赋值，必须类型和维数都一样
        int[] arr1 = new int[10];
        byte[] arr2 = new byte[20];
//        arr1 = arr2;     //编译不通过，原因：int[],byte[]是两种不同类型的引用变量
        System.out.println(arr1);
        System.out.println(arr2);

        int[][] arr3 = new int[3][2];
//        arr3 = arr1;     //编译不通过，维数不同

        arr3[0] = arr1;
    }
}
```

```java
public class ArrayExer03 {
    public static void main(String[] args) {
        String[][] employees = {
                {"10", "1", "段誉  ", "22", "3000"},
                {"13", "2", "令狐冲", "32", "18000", "15000", "2000"},
                {"11", "3", "任我行", "23", "7000"},
                {"11", "4", "张三丰", "24", "7300"},
                {"12", "5", "周芷若", "28", "10000", "5000"},
                {"11", "6", "赵敏  ", "22", "6800"},
                {"12", "7", "张无忌", "29", "10800", "5200"},
                {"13", "8", "韦小宝", "30", "19800", "15000", "2500"},
                {"12", "9", "杨过  ", "26", "9800", "5500"},
                {"11", "10", "小龙女", "21", "6600"},
                {"11", "11", "郭靖  ", "25", "7100"},
                {"11", "12", "黄蓉  ", "27", "9600", "4800"}
        };
        System.out.println("员工类型\t编号\t姓名\t\t年龄\t薪资\t\t奖金\t\t股票");

        for (int i = 0; i < employees.length; i++){
            String employeeType = employees[i][0];
            switch (employeeType){
                case "10":
                    System.out.print("普通职员\t");
                    break;
                case "11":
                    System.out.print("程序员\t");
                    break;
                case "12":
                    System.out.print("设计师\t");
                    break;
                case "13":
                    System.out.print("架构师\t");
                    break;

            }
            for (int j = 1; j < employees[i].length; j++){
                System.out.print(employees[i][j] + "\t");
            }
            System.out.println();
        }
    }
}
```

## 5. 数组的常见算法

### 5.1 数值型数组特征值统计

这里的特征值涉及到：平均值、最大值、最小值、总和等

```java
public class ArrayExer01_function {
    public static void main(String[] args) {
        //1. 动态初始化方式创建数组
        int[] arr = new int[10];
        //2. 通过循环给数组元素赋值
        for (int i = 0; i < arr.length; i++){
            arr[i] = (int)(Math.random() * (99 - 10 + 1)) + 10;
            System.out.print(arr[i] + "\t");
        }
        System.out.println();

        //3.1 求最大值
        int max = arr[0];
        for (int i = 1; i < arr.length; i++){
            if (arr[i] > max){
                max = arr[i];
            }
        }
        System.out.println("max:" + max);

        //3.2 求最小值
        int min = arr[0];
        for (int i = 1; i < arr.length; i++){
            if (arr[i] < max){
                min = arr[i];
            }
        }
        System.out.println("min:" + min);

        //3.3 求总和
        int sum = 0;
        for (int i = 0; i < arr.length; i++){
            sum += arr[i];
        }
        System.out.println("sum:" + sum);

        //3.4 求平均值
        double aver = (double) sum / arr.length;
        System.out.println("aver:" + aver);
    }
}
```

```java
/**
 * Description:
 *          (1)在编程竞赛中，有10位评委为参赛的选手打分，分数分别为：5,4,6,8,9,0,1,2,3,7
 *          (2)求选手的最后得分(去掉一个最高分和一个最低分后其余8位评委打分的平均分)
 */
public class ArrayExer02 {
    public static void main(String[] args) {

        int[] scores = new int[]{5, 4, 6, 8, 9, 0, 1, 2, 3, 7};

        int sum = 0, max = scores[0], min = scores[0];
        for (int i = 1; i < scores.length; i++){
            if (scores[i] > max){
                max = scores[i];
            }
            if (scores[i] < min){
                min = scores[i];
            }
            sum += scores[i];
        }

        double avg = (double) (sum - max - min) / (scores.length - 2);
        System.out.println("去掉最高分和最低分之后，平均分为：" + avg);
    }
}
```

### 5.2 数组元素的赋值与数组复制

```java
/**
 * Description:
 * 使用二维数组打印一个10行的杨辉三角
 */
   public class ArrayExer03 {
   public static void main(String[] args) {
       int[][] yanghui = new int[10][];
       for (int i = 0; i < yanghui.length; i++){
           yanghui[i] = new int[i+1];
           yanghui[i][0] = 1;
           yanghui[i][i] = 1;
           for(int j = 0; j <= i; j++){
               if (j > 0 && j < i) {
                   yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];
               }
               System.out.print(yanghui[i][j] + "\t");
           }
           System.out.println();
       }
   }
   }
```

```java
/**
 * Description:
 *          创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值，同时要求元素的值各不相同
 */
public class ArrayExer04 {
    public static void main(String[] args) {
        int[] arr = new int[6];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)(Math.random() * 30) + 1;

            for (int j = 0; j < i; j++) {
                if (arr[i] == arr[j]){
                    i--;
                    break;
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
```

<font color="#c43c3c">**回型数**</font>

```java
/**
 * Description:
 *          回形数
 *          从键盘输入一个整数（1-20），则以该数字为矩阵的大小，把1、2、...、n²的数字按照顺时针螺旋的形式填入其中
 */
public class ArrayExer05 {
}
```



```java
/**
 * Description:
 * (1) 创建一个明位ArrayTest的类，在main()方法中声明array1和array2两个变量，它们是int[]类型的数组。
 * (2) 使用{}，把array1初始化为8个素数：2, 3, 5, 7, 11, 13, 17, 19
 * (3) 显示array1的内容
 * (4) 赋值array2变量等于array1，修改array2中的偶索引元素，使其等于索引值。
 * (5) 打印出array1
 */
public class ArrayExer06 {
    public static void main(String[] args) {
        int[] array1, array2, array3;
        array1 = new int[]{2, 3, 5, 7, 11, 13, 17, 19};
        for (int k : array1) {
            System.out.print(k + "\t");
        }
        //赋值情况下：
        array2 = array1;
        for (int i = 0; i < array2.length; i++){
            if (i % 2 == 0){
                array2[i] = i;
            }
        }
        System.out.println();
        for (int j : array1) {
            System.out.print(j + "\t");
        }
        //array1也会改变，因为赋值的是地址值


        System.out.println();
        //复制情况下：
        array3 = new int[array1.length];
        for (int i = 0; i < array1.length; i++){
            array3[i] = array1[i];
            System.out.print(array1[i] + "\t");
        }
        for (int i = 0; i < array3.length; i++){
            if (i % 2 != 0){
                array3[i] = i;
            }
        }
        System.out.println();
        for (int i = 0; i < array1.length; i++){
            System.out.print(array1[i] + "\t");
        }
    }
}
```

### 5.3 数组元素的反转

```java
/**
 * Description:
 *          数组的反转
 */
public class ArrayExer07 {
    public static void main(String[] args) {
        int[] arr = new int[]{34, 54, 3, 2, 65, 7, 34, 5 ,76, 34, 67};
        //方式1：
//        for (int i = 0; i < arr.length / 2; i++){
//            int temp = arr[i];
//            arr[i] = arr[arr.length-1-i];
//            arr[arr.length-1-i] = temp;
//        }
//        System.out.println();
        //方式2：双指针
        for (int i = 0, j = arr.length-1; i < j; i++, j--){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

        //方式3：额外开辟新内存，完全不推荐
//        int[] newArr = new int[arr.length];
//        for (int i = 0; i < arr.length; i++){
//            newArr[i] = arr[arr.length-1-i];
//        }

        for (int i = 0; i < arr.length; i++){
            System.out.print(arr[i] + "\t");
        }
    }
}
```

### 5.4 数组的扩容与缩容

```java
/**
 * Description:
 *          数组的扩容
 */
public class ArrayExer01_1 {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 2, 3, 4, 5};

        //扩容1倍容量
        int[] newArr = new int[arr.length << 1];

        for (int i = 0; i < arr.length; i++){
            newArr[i] = arr[i];
        }
        newArr[arr.length] = 10;
        newArr[arr.length + 1] = 20;
        newArr[arr.length + 2] = 30;
        arr = newArr;      //更改指针指向
        //原来arr指向的地址现在已经没有指针指向，GC之后会回收(堆空间不太够时)

        for (int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
```

```java
/**
 * Description:
 *          数组缩容
 */
public class ArrayExer01_2 {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7};

        int deleteIndex = 4;

        //方式1：不新建数组
//        for(int i = deleteIndex; i < arr.length-1; i++){
//            arr[i] = arr[i+1];
//        }
//        修改最后一个元素，设置为默认值
//        arr[arr.length-1] = 0;

        //方式2：新建数组，新的数组的长度比原有数组的长度少1
        int[] newArr = new int[arr.length-1];
        for (int i = 0; i < deleteIndex; i++){
            newArr[i] = arr[i];
        }

        for (int i = deleteIndex; i < newArr.length; i++){
            newArr[i] = arr[i+1];
        }
        arr = newArr;
        for (int i = 0; i < arr.length; i++){
            System.out.print(arr[i] + "\t");
        }
    }
}
```



### 5.5 数组的元素查找

<font color="#c43c3c">**顺序查找/线性查找**</font>

- 优点：算法简单
- 缺点：效率低。执行时间复杂度为O(N)

```java
/**
 * Description:
 *          线性查找
 */
public class LinearSearchTest {
    public static void main(String[] args) {
        int[] arr = new int[]{34, 54, 3, 2, 65, 7, 34, 5, 76, 34, 67};

        int target = 5;
        boolean isFlag = true;
        for (int i = 0; i < arr.length; i++){
            if(target == arr[i]){
                System.out.println("找到了" + target + "对应的位置为：" + i);
                isFlag = false;
                break;
            }
        }
        if(isFlag){                                //if (i == arr.length)
            System.out.println("没找到");
        }
    }
}
```

<font color="#c43c3c">**二分查找**</font>

- 优点：执行效率高。执行时间复杂度为O(logN)
- 缺点：算法相较于顺序查找难一点；数组必须是有序的

```java
/**
 * Description:
 *          二分查找
 */
public class BinarySearchTest {
    public static void main(String[] args) {
        int[] arr = new int[]{2, 4, 5, 8, 12, 15, 19, 26, 37, 49, 51, 66, 89, 100};

        int target = 17;
        int head = 0, end = arr.length-1;   //双指针
        boolean isFlag = true;

        while (head <= end){
            int mid = (head + end) / 2;

            if(target == arr[mid]) {
                System.out.println("找到了" + target + "对应的位置为：" + mid);
                isFlag = false;
                break;
            }else if(target > arr[mid]){
                head = mid + 1;
            }else {
                end = mid - 1;
            }
        }
        if(isFlag){
            System.out.println("没找到");
        }
    }
}
```



### 5.6 数组元素排序

#### 5.6.1 算法概述

- <font color="#c43c3c">**定义**</font>

  - 排序：假设含有n个记录的序列为{R1,R2,...,Rn}，其相应的关键字序列为{K1,K2,...,Kn}。将这些记录重新排序为{Ri1,Ri2,...,Rin}，使得相应的关键字值满足Ki1<=Ki2<=...<=Kin，这样的一种操作称为排序。
  - 通常来说，排序的目的是快速查找。

- <font color="#c43c3c">**衡量排序算法的优劣**</font>

  - <font color="#FF9900">`时间复杂度`</font>：分析关键字的比较次数和记录的移动次数

- 常见的算法时间复杂度由小到大依次为：<font color="#c43c3c">**O(1)<O(logN)<O(N)<O(nlogN)<O(N^2^)<O(N^3^)<...<O(2^N^)<O(N!)<O(N^N^)**</font>

- <font color="#FF9900">`空间复杂度`</font>：分析排序算法中需要多少辅助内存

  `一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数`

  - <font color="#FF9900">`稳定性`</font>：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。

#### 5.6.2 排序算法概述

- <font color="#c43c3c">**排序算法分类：内部排序和外部排序**</font>

  - <font color="#FF9900">`内部排序`</font>：整个排序过程不需要借助外部存储器(如磁盘等)，所有的排序操作都在内存中完成。
  - <font color="#FF9900">`外部排序`</font>：参与排序的数据非常多，数据量非常大，计算机无法将整个排序过程放在内存中完成，必须借助于外部存储器(如磁盘)。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。

- <font color="#c43c3c">**十大内部排序算法**</font>：

  数组的排序算法很多，实现方式各不相同，时间复杂度、空间复杂度、稳定性也各不相同：

  | 排序方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度   | 稳定性 |
  | -------- | ---------------- | ---------------- | ---------------- | ------------ | ------ |
  | 插入排序 | O(n^2^)          | O(n^2^)          | O(n)             | O(1)         | 稳定   |
  | 希尔排序 | O(n^1.3^)        | O(n^2^)          | O(n)             | O(1)         | 不稳定 |
  | 选择排序 | O(n^2^)          | O(n^2^)          | O(n^2^)          | O(1)         | 不稳定 |
  | 堆排序   | O($nlog_2n$)     | O($nlog_2n$)     | O($nlog_2n$)     | O(1)         | 不稳定 |
  | 冒泡排序 | O(n^2^)          | O(n^2^)          | O(n)             | O(1)         | 稳定   |
  | 快速排序 | O($nlog_2n$)     | O(n^2^)          | O($nlog_2n$)     | O($nlog_2n$) | 不稳定 |
  | 归并排序 | O($nlog_2n$)     | O($nlog_2n$)     | O($nlog_2n$)     | O(n)         | 稳定   |
  | 计数排序 | O(n+k)           | O(n+k)           | O(n+k)           | O(n+k)       | 稳定   |
  | 桶排序   | O(n+k)           | O(n^2^)          | O(n)             | O(n+k)       | 稳定   |
  | 基数排序 | O(n*k)           | O(n*k)           | O(n*k)           | O(n+k)       | 稳定   |

#### 5.6.3 冒泡排序(Bubble Sort)

<font color="#c43c3c">**思想**</font>：每次比较“相邻(位置相邻)”元素，如果它们不符合目标顺序(例如升序)就交换它们，经过多轮比较，最终实现排序。(每轮可以把最大的沉底/最小的冒顶)

动态演示：https://visualg0.net/zh/sorting

```java
public class BubbleSortTest {
    public static void main(String[] args) {
        int[] arr = new int[]{34, 54, 3, 2, 65, 7, 34, 5, 76, 34, 67};

        //遍历
        for (int i = 0; i < arr.length; i++){
            System.out.print(arr[i] + "\t");
        }
        System.out.println();
        //冒泡排序，实现数组元素从小到大排列
//        for(int i = 0; i < arr.length -1; i++){
//            for(int j = 0; j < arr.length - i - 1; j++){
//                if(arr[j] > arr[j+1]){
//                    int temp = arr[j];
//                    arr[j] = arr[j+1];
//                    arr[j+1] = temp;
//                }
//            }
//        }

        //冒泡排序的优化
        for(int i = 0; i < arr.length -1; i++){
            boolean flag = true;
            for(int j = 0; j < arr.length - i - 1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                    flag = false;
                }
            }
            if (flag){
                break;
            }
        }
        //遍历
        for (int i = 0; i < arr.length; i++){
            System.out.print(arr[i] + "\t");
        }
    }
}
```

#### 5.6.4 快速排序

快速排序(Quick Sort)由<font color="#FF9900">图灵奖</font>获得者<font color="#FF9900">Tony Hoare</font>发明，被列为<font color="#FF9900">20世纪十大算法之一</font>，是迄今为止所有算法中速度最快的一种，快速排序的时间复杂度为O($ nlog_2n$)。

快速排序通常比同为O($ nlog_2n$)的其他所发更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。

<font color="#c43c3c">**思想**</font>：

- 从数列中跳出一个元素，称为“基准”(pivot)。
- 重新排序数列，所有元素比基准小的值摆放在基准前面，所有元素比基准大的值摆放在基准后面。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。
- 递归地把小于基准值的元素的子数列和大于基准值的子数列排序。
- 递归的最底部情况，是数列的大小是0/1，也就是永远都已经被排好序了。虽然一直递归下去，但是这个算法总会结束，因为每次的迭代中，它至少会把一个元素摆到它最后的位置去
- 每排序一趟时间复杂度为O(n)，要排$log2n$次

==（                                       重要                                         ）==

```java
public class QuickSortTest {
    public static void main(String[] args) {
        int[] data = {9, -16, 30, 23, -30, -49, 25, 21, 30};
        System.out.println("排序之前：");
        for (int i = 0; i < data.length; i++){
            System.out.print(data[i] + "  ");
        }

        quickSort(data);       //调用实现快排的方法

        System.out.println("\n排序之后：");
        for (int i = 0; i < data.length; i++){
            System.out.print(data[i] + "  ");
        }
    }


    public static void quickSort(int[] data){
        subSort(data, 0, data.length-1);
    }

    private static void subSort(int[] data, int start, int end){
        if (start < end){
            int base = data[start];
            int low = start;
            int high = end + 1;
            while (true){
                while (low < end && data[++low] - base <= 0){
                    //找到大于基准的数
                    ;
                }
                while (high > start && data[--high] - base >= 0){
                    //找到小于基准的数
                    ;
                }
                if (low < high){
                    //交换data数组[low]和[high]位置的元素
                    swap(data, low, high);
                }else {
                    break;
                }
            }
            //交换data数组[start]与[high]位置的元素
            swap(data, start, high);

            //经过代码[start,high)部分的元素比[high,end]都小

            //通过递归调用，对data数组[start,high-1]部分的元素重复刚才的过程
            subSort(data, start, high-1);
            //通过递归调用，对data数组[high+1,end]部分的元素重复刚才的过程
            subSort(data, high+1, end);
        }
    }

    private static void swap(int[] data, int i, int j){
        int temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }
}
```



#### 5.6.5 内部排序性能比较与选择

## 6. Arrays工具类的使用

`java.util.Arrays`类即为操作数组的工具类，包含了用来操作数组(比如排序和搜索)的各种方法。比如：

- <font color="#FF9900">数组元素拼接</font>
  - `static String toString(int[] a)`：字符串表示形式由数组的元素列表组成，括在('[]')中。相邻元素用字符", "(逗号加空格)分隔。形式为：[元素1, 元素2, 元素3, ...]
  - `static String toString(Object[] a)`:字符串表示形式由数组的元素列表组成，括在('[]')中。元素讲自动调用自己从Object继承的toString方法将对象转为字符串进行拼接，如果没有重写，则返回@hash值，如果重写则按重写返回的字符串进行拼接
- <font color="#FF9900">数组排序</font>
  - `static void sort(int][] a)`：将a数组按照从小到大排序
  - `static void sort(int][] a, int fromIndex, int toIndex)`：将a数组的[fromIndex, toIndex]部分按照升序排序
  - `static void sort(Object[] a)`：根据元素的自然顺序对指定对象数组按升序进行排序。
  - `static <T> void sort(T[] a, Comparator<? super T>c)`：根据指定比较器产生的顺序对指定对象数据进行排序
- <font color="#FF9900">数组元素的二分查找</font>
  - `static int binarySearch(int[] a, int key)、static int binarySearch(Object[] a, Object key)`：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数

```java
public class ArraysTest {
    public static void main(String[] args) {
        //1. static boolean equals(int[] a, int[] a2)：比较两个数组的元素是否依次相同
        int[] arr1 = new int[]{1, 2, 3, 4, 5};
        int[] arr2 = new int[]{1, 2, 3, 4, 5};

        System.out.println(arr1 == arr2);  //false

        boolean isEquals = Arrays.equals(arr1, arr2);
        System.out.println(isEquals);     //true

        arr2 = new int[]{1, 2, 3, 5, 4};
        isEquals = Arrays.equals(arr1, arr2);
        System.out.println(isEquals);     //false


        //2. static String toString(int[] a)：输出数组元素信息
        System.out.println(arr1);
        System.out.println(Arrays.toString(arr1));


        //3. static void fill(int[] a, int val)：将指定值填充到数组中
        Arrays.fill(arr1, 10);
        System.out.println(Arrays.toString(arr1));

        //4. static void sort(int][] a)：使用快排算法实现的排序
        int[] arr3 = new int[]{34, 54, 3, 2, 65, 7, 34, 5, 76, 34, 67};
        Arrays.sort(arr3);
        System.out.println(Arrays.toString(arr3));

        //5. static int binarySearch(int[] a, int key)：二分查找
        //前提：有序
        int index = Arrays.binarySearch(arr3, 5);
        System.out.println(index);
        index = Arrays.binarySearch(arr3, 15);
        System.out.println(index);

    }
}

```

## 7. 数组中的常见异常

### 7.1 数组角标越界异常

`ArrayIndexOutOfBoundsException`：操作的索引超出了数组索引范围了

注：与python不同，<font color="#ff9900">不能出现负索引</font>

### 7.2 空指针异常

`NullPointerException`：当一个对象为null时,再调用此对象中的其他成员

```java
//情况1：
int[] arr1 = new int[10];
arr1 = null;
System.out.println(arr1[1]);     //空指针异常

//情况2：
int[][] arr2 = new int[3][];
System.out.println(arr[2][1]);   //空指针异常

//情况3：
String[] arr3 = new String[4];
System.out.println(arr3[0].toString());  //空指针异常
```







----



```java
课前回顾:
   1.Scanner:
    a.导包: import java.util.Scanner
    b.创建对象:Scanner 名字 = new Scanner(System.in)
    c.调用方法:
      nextInt()录入一个整数
      next()录入一个字符串,遇到空格和回车就结束
      nextLine()录入一个字符串,遇到回车就结束
  2.switch:选择语句
    a.格式:
      switch(变量){
          case 常量值1:
              执行语句1;
              break;
          case 常量值2:
              执行语句2;
              break;
          ...
              default:
              执行语句n;
              break;
      }
    b.执行流程:用变量代表的值去精准匹配,配上哪个case就走哪个case对应的执行语句,如果都配不上,就走default
               
    c.没有break:会出现case的穿透性,一直穿透,直到遇到break或者switch结束为止

  3.if...else:
    a.格式:
      if(boolean表达式){
          执行语句1
      }else{
          执行语句2
      }
    b.执行流程:
      先走if后面的boolean表达式,如果是true,就走if后面的执行语句1,否则就走else后面的执行语句2
  4.else...if
    a.格式:
      if(boolean表达式){
          执行语句1
      }else if(boolean表达式){
          执行语句2
      }else if(boolean表达式){
          执行语句3
      }...else{
          执行语句n
      }
    b.执行流程:
      从上到下挨个判断,哪个条件为true,就走哪个if对应的执行语句,以上所有的if都没有匹配上,走else
          
 5.for循环:
   a.格式:
     for(初始化变量;比较;步进表达式){
         循环语句
     }
   b.执行流程:
     先初始化变量,比较,如果是true,走循环语句
     走步进表达式,再比较,如果还是true,继续循环,直到比较为false,循环结束
         
6.while循环:
   a.格式:
     初始化变量;
     while(比较){
         循环语句
         步进表达式
     }
   b.执行流程
     先初始化变量,比较,如果是true,走循环语句
     走步进表达式,再比较,如果还是true,继续循环,直到比较为false,循环结束
       
 7.do...while循环:
   a.格式:
     初始化变量;
     do{
         循环语句
         步进表达式
     }while(比较);
   b.执行流程:
     初始化变量;
     循环语句
     步进表达式
     比较,如果是true,继续循环,直到比较为false
 8.死循环:比较永远是true
 9.嵌套循环:

   先走外层循环,再走内层循环,内层循环就一直循环,直到内层循环结束了,外层循环再进入下一次循环,直到连外层循环都结束了,循环整体结束
       
 10.循环控制关键字:
   break:结束循环
   continue:结束本次循环进入下一次循环
       
 9.Random
   a.概述:java定义好的类
   b.作用:在指定的范围内随机一个数
   c.使用:
     导包-> import java.util.Random
     创建对象-> Random 对象名 = new Random()
     调用方法: 
        对象名.nextInt() 在int的取值范围内随机一个数
        对象名.nextInt(int bound) -> 在0-(bound-1)之间随机

模块五重点:
  1.数组的定义和特点
  2.数组的操作(存数据,取数据,遍历数据)
  3.二维数组(定义,取,存,遍历)
```

# 第一章.数组的定义

```java
1.问题:想将一个数据保存起来,我们可以使用变量,但是变量一次只能存储一个数据,所以我们想能不能一次存多个数据
    
2.数组概述:是一个容器,数组本身属于引用数据类型
    
3.作用:一次存储多个数据
    
4.特点:
  a.既可以存储基本类型的数据,还能存储引用类型的数据
  b.定长(定义数组时长度为多长,最多就能存多少个数据) 
      
5.定义:
  a.动态初始化:
    数据类型[] 数组名 = new 数据类型[长度]
    数据类型 数组名[] = new 数据类型[长度]    
    
    各部分解释:
      等号左边的数据类型:规定了数组中只能存储什么类型的元素
      []:代表的是数组,一个[]代表一维数组,两个[][]代表二维数组    
      数组名:自己取的名字,遵循小驼峰
      new:代表的是创建数组
      等号右边的数据类型:要和等号左边的数据类型一致
      [长度]:指定数组长度,规定了数组最多能存多少个数据    
          
  b.静态初始化
    数据类型[] 数组名 = new 数据类型[]{元素1,元素2...}  -> 不推荐使用 
    数据类型 数组名[] = new 数据类型[]{元素1,元素2...}  -> 不推荐使用    

  c.简化的静态初始化:
    数据类型[] 数组名 = {元素1,元素2...}-> 推荐使用
        
        
6.区别:
  a.动态初始化:定义的时候只指定了长度,没有存具体的数据
             当只知道长度,但不知道具体存啥数据时可以使用动态初始化
      
  
  b.静态初始化:定义的时候就直接知道存啥了   
```

```java
public class Demo01Array {
    public static void main(String[] args) {
        //动态初始化
        int[] arr1 = new int[3];
        String[] arr2 = new String[3];

        //静态初始化
        int[] arr3 = new int[]{1,2,3,4,5};

        //简化静态初始化
        int[] arr4 = {1,2,3,4,5};
        
        String[] arr5 = {"乾隆","和珅","纪晓岚"};
    }
}
```

# 第二章.数组操作

## 1.获取数组的长度

```java
1.格式:
  数组名.length
      
2.注意:
  length后面不要带小括号,因为length不是一个方法,而是数组中的一个属性
```

```java
public class Demo01Array {
    public static void main(String[] args) {
        //定义一个数组
        String[] arr1 = {"迪迦奥特曼","猫和老鼠","花园宝宝","海绵宝宝","圣斗士","百变小樱魔术卡","熊出没"};
        int len = arr1.length;
        System.out.println("len = " + len);
    }
}
```

## 2.索引

```java
1.概述:元素在数组中存储的位置
    
2.特点:
  a.索引唯一
  b.索引都是从0开始的,最大索引是数组长度-1 
      
3.注意:
  我们将来操作元素,必须通过索引来操作
  存数据,要指定索引
  取数据,要指定索引
  查数据,要指定索引
```

<img src="img/1693100078309.png" alt="1693100078309" style="zoom:80%;" />

## 3.存储元素

```java
1.格式:
  数组名[索引值] = 值 -> 将等号右边的值放到数组指定的索引位置上
```

```java
public class Demo02Array {
    public static void main(String[] args) {
        int[] arr = new int[3];
        arr[0] = 100;//将100存到了arr这个数组的0索引上
        arr[1] = 200;//将200存到了arr这个数组的1索引上
        arr[2] = 300;//将300存到了arr这个数组的2索引上
        //arr[3] = 1000;

        System.out.println("============================");
        
        String[] arr1 = new String[3];
        arr1[0] = "东方不败";
        arr1[1] = "岳不群";
        arr1[2] = "林平之";
    }
}
```

```java
public class Demo03Array {
    public static void main(String[] args) {
        //键盘录入三个整数,存储到数组中
        int[] arr = new int[3];

        Scanner sc = new Scanner(System.in);

        /*
          先看等号右边的,先录入,将录入的数据保存到指定的索引位置上
         */
      /*  arr[0] = sc.nextInt();
        arr[1] = sc.nextInt();
        arr[2] = sc.nextInt();*/

       /* for (int i = 0; i < 3; i++) {
            arr[i] = sc.nextInt();
        }*/
        
        for (int i = 0; i < arr.length; i++) {
            arr[i] = sc.nextInt();
        }
        
    }
}

```

```java
public class Demo04Array {
    public static void main(String[] args) {
        //定义一个长度为3的数组
        int[] arr = new int[3];
        Random rd = new Random();

        //arr[0] = rd.nextInt(10);
        //arr[1] = rd.nextInt(10);
        //arr[2] = rd.nextInt(10);

        for (int i = 0;i<arr.length;i++){
            /*
              先看等号右边的,先随机一个数保存到指定的索引位置上
             */
            arr[i] = rd.nextInt(10);
        }
    }
}
```

## 4.获取元素

```java
1.地址值:
  数组在内存中的身份证号,唯一标识,我们可以通过这个唯一标识到内存中准确找到这个数,从而操作这个数组中的数据
      
2.注意:
  a.直接输出数组名,会直接输出数组在内存中的地址值 
  b.如果数组中没有存元素,那么直接获取索引上对应的元素也是有值的,只不过不是我们存储的数据,而是数组中的元素默认值
    整数: 0
    小数: 0.0
    字符: '\u0000' -> 空白字符 -> 对应的int值是0
    布尔: false
    引用: null    
```

```java
public class Demo05Array {
    public static void main(String[] args) {
        int[] arr = new int[3];
        arr[0] = 100;
        arr[1] = 200;
        arr[2] = 300;
        System.out.println(arr);//[I@135fbaa4 -> 地址值
        System.out.println(arr[0]);//输出0索引上的元素
        System.out.println(arr[1]);//输出1索引上的元素
        System.out.println(arr[2]);//输出2索引上的元素

        int[] arr1 = new int[3];
        arr1[0] = 1000;
        arr1[1] = 2000;
        arr1[2] = 3000;
        System.out.println(arr1);//[I@45ee12a7
        System.out.println(arr1[0]);//输出0索引上的元素
        System.out.println(arr1[1]);//输出1索引上的元素
        System.out.println(arr1[2]);//输出2索引上的元素

        System.out.println("=============================");

        int[] arr2 = new int[3];
        System.out.println(arr2[0]);//输出0索引上的元素    0
        System.out.println(arr2[1]);//输出1索引上的元素    0
        System.out.println(arr2[2]);//输出2索引上的元素    0

    }
}

```

<img src="img/1693104779382.png" alt="1693104779382" style="zoom:80%;" />



<img src="img/1693105444875.png" alt="1693105444875" style="zoom:80%;" />



```java
public class Demo06Array {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6};
        //需求:将arr中的数据放到另外一个数组中

        /*
          如果我们想将arr中的数据复制到新数组中
          那么新数组的长度就应该是arr数组的长度
         */
        int[] newArr = new int[arr.length];

        System.out.println(newArr[0]);//默认值0
        System.out.println(newArr[1]);//默认值0
        System.out.println(newArr[2]);//默认值0
        System.out.println(newArr[3]);//默认值0
        System.out.println(newArr[4]);//默认值0
        System.out.println(newArr[5]);//默认值0

        
        /*
          将arr数组指定索引位置上的元素获取出来放到等号左边newArr数组的指定索引位置上
         */
        newArr[0] = arr[0];
        newArr[1] = arr[1];
        newArr[2] = arr[2];
        newArr[3] = arr[3];
        newArr[4] = arr[4];
        newArr[5] = arr[5];

        System.out.println(newArr[0]);
        System.out.println(newArr[1]);
        System.out.println(newArr[2]);
        System.out.println(newArr[3]);
        System.out.println(newArr[4]);
        System.out.println(newArr[5]);
    }
}

```

> arr[0] = arr1[0] 
>
> 如果数组名[索引值]在等号右边就代表获取
>
> 如果数组名[索引值]在等号左边就代表存值
>
> 比如 :
>
> a.int element = arr[0] -> 获取0索引上的元素,赋值给一个变量
>
> b.arr[0] = 100 -> 将100存储到0索引上
>
> c.arr[0] = arr1[0]  -> 将arr1的0索引上的元素获取出来,赋值给等号左边arr的0索引上

## 5.遍历数组

```java
1.遍历:将元素从数组中一个一个的获取出来
```

```java
public class Demo07Array {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6};
        /*for (int i = 0; i < 6; i++){
            System.out.println(arr[i]);
        }*/

       /* for (int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }*/
        
        /*
           快速遍历快捷键: 数组名.fori
         */
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

```

> ```java
> 快速遍历快捷键: 数组名.fori
> ```
>
> ```java
> public class Demo08Array {
>     public static void main(String[] args) {
>         int[] arr = {1,2,3,4,5,6};
>         //需求:将arr中的数据放到另外一个数组中
> 
>         /*
>           如果我们想将arr中的数据复制到新数组中
>           那么新数组的长度就应该是arr数组的长度
>          */
>         int[] newArr = new int[arr.length];
> 
>         System.out.println(newArr[0]);//默认值0
>         System.out.println(newArr[1]);//默认值0
>         System.out.println(newArr[2]);//默认值0
>         System.out.println(newArr[3]);//默认值0
>         System.out.println(newArr[4]);//默认值0
>         System.out.println(newArr[5]);//默认值0
> 
> 
>         /*
>           将arr数组指定索引位置上的元素获取出来放到等号左边newArr数组的指定索引位置上
>          */
>        /* newArr[0] = arr[0];
>         newArr[1] = arr[1];
>         newArr[2] = arr[2];
>         newArr[3] = arr[3];
>         newArr[4] = arr[4];
>         newArr[5] = arr[5];*/
> 
> 
>         for (int i = 0; i < arr.length; i++) {
>             newArr[i] = arr[i];
>         }
> 
>         //遍历
>         for (int i = 0; i < newArr.length; i++) {
>             System.out.println(newArr[i]);
>         }
>     }
> }
> ```

# 第三章.操作数组时两个常见的问题

## 1.数组索引越界异常_ArrayIndexOutOfBoundsException

```java
1.原因:
  操作的索引超出了数组索引范围了
```

```java
public class Demo09Array {
    public static void main(String[] args) {
        int[] arr = new int[3];
        arr[0] = 100;
        arr[1] = 200;
        arr[2] = 300;
        //arr[3] = 400;//索引3超出了arr的索引范围

        //arr[-1] = 1000;//索引3超出了arr的索引范围

        for (int i = 0; i <= arr.length; i++) {
            System.out.println(arr[i]);//索引3超出了arr的索引范围
        }
    }
}
```

## 2.空指针异常_NullPointerException

```java
1.原因:
  当一个对象为null时,再调用此对象中的其他成员
```

```java
public class Demo10Array {
    public static void main(String[] args) {

        int[] arr = new int[3];
        System.out.println(arr.length);//3
        arr = null;
        System.out.println(arr.length);//NullPointerException
    }
}

```

<img src="img/1693117140845.png" alt="1693117140845" style="zoom:80%;" />

> 以上两个问题我们只需要知道原因即可

# 第四章.数组练习

## 1.练习

```java
第一题:需求:求出数组中的元素最大值
步骤:
  1.定义一个max,接收两个元素之间的较大值
  2.遍历数组,将每一个元素获取出来进行比较
  3.判断,如果max小于遍历出来的元素,证明遍历出来的元素大,将大的元素赋值给max
  4.直接输出max    
   
```

<img src="img/1693117878368.png" alt="1693117878368" style="zoom:80%;" />

```java
public class Demo01GetMax {
    public static void main(String[] args) {
        int[] arr = {5,3,5,7,4,6,8,9};
        //1.定义一个max,接收两个元素之间的较大值
        int max = arr[0];
        //2.遍历数组,将每一个元素获取出来进行比较
        for (int i = 1; i < arr.length; i++) {
        //3.判断,如果max小于遍历出来的元素,证明遍历出来的元素大,将大的元素赋值给max
            if (max<arr[i]){
                max = arr[i];
            }
        }
        //4.直接输出max
        System.out.println("max = " + max);
    }
}
```

## 2.练习

```java
随机产生10个[0,100]之间整数，统计既是3又是5，但不是7的倍数的个数
步骤:
 1.创建一个Random对象,用于搞随机数
 2.定义一个数组,长度为10
 3.定义一个变量count,用来统计个数
 4.遍历数组,判断元素是否符合指定条件,如果符合,count++
 5.输出count    
```

```java
public class Demo02Count {
    public static void main(String[] args) {
        //1.创建一个Random对象,用于搞随机数
        Random rd = new Random();
        //2.定义一个数组,长度为10
        int[] arr = new int[10];
        //3.定义一个变量count,用来统计个数
        int count = 0;

        for (int i = 0; i < arr.length; i++) {
            arr[i] = rd.nextInt(101);
        }

        for (int i = 0; i < arr.length; i++) {
        //4.遍历数组,判断元素是否符合指定条件,如果符合,count++
           if (arr[i]%3==0 && arr[i]%5==0 && arr[i]%7!=0){
               count++;
           }
        }
        //5.输出count
        System.out.println("count = " + count);
    }
}
```

## 3.练习

```java
用一个数组存储本组学员的姓名，从键盘输入，并遍历显示
```

```java
public class Demo03Print {
    public static void main(String[] args) {
        String[] arr = new String[3];
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < arr.length; i++) {
            System.out.println("请您输入第"+(i+1)+"个学员姓名:");
            arr[i] = sc.next();
        }

        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

```

## 4.练习

```java
需求:
  1.定义一个数组 int[] arr = {1,2,3,4}
  2.遍历数组,输出元素按照[1,2,3,4]
```

```java
public class Demo04PrintRegex {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4};
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            if (i == arr.length - 1) {
                System.out.print(arr[i] + "]");
            } else {
                System.out.print(arr[i] + ",");
            }
        }
    }
}

```

## 5.练习

```java
需求:随机50个1-100之间的整数,统计偶数个数
```

```java
public class Demo05Count {
    public static void main(String[] args) {
        //定义长度为50的数组
        int[] arr = new int[50];
        //创建Random对象
        Random rd = new Random();
        //存数据
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rd.nextInt(100)+1;
        }

        //定义一个count,用于统计偶数个数
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i]%2==0){
                count++;
            }
        }

        System.out.println("count = " + count);
    }
}

```

## 6.练习

```java
键盘录入一个整数,找出整数在数组中存储的索引位置

步骤:
  1.创建Scanner对象
  2.定义数组,随便存几个数据
  3.遍历数组,在遍历的过程中判断是否和录入的数相等,如果相等,输出索引
```

```java
public class Demo06Search {
    public static void main(String[] args) {
        //1.创建Scanner对象
        Scanner sc = new Scanner(System.in);
        //2.定义数组,随便存几个数据
        int[] arr = {11,22,33,44,55,66,22};
        int data = sc.nextInt();
        //3.遍历数组,在遍历的过程中判断是否和录入的数相等,如果相等,输出索引
        for (int i = 0; i < arr.length; i++) {
            if (data==arr[i]){
                System.out.println(i);
            }
        }
    }
}
```

```java
问题升级:如果查不到,输出-1,代表没有查到
```

```java
public class Demo06Search {
    public static void main(String[] args) {
        //1.创建Scanner对象
        Scanner sc = new Scanner(System.in);
        //2.定义数组,随便存几个数据
        int[] arr = {11,22,33,44,55,66,22};
        int data = sc.nextInt();

        //定义一个变量,此变量用来表示是否有要查找的数据
        int flag = 0;


        //3.遍历数组,在遍历的过程中判断是否和录入的数相等,如果相等,输出索引
        for (int i = 0; i < arr.length; i++) {
            if (data==arr[i]){
                System.out.println(i);
                flag++;
            }
        }

        /*
           4.判断flag是否还为0,如果遍历完,比较完之后,出了for循环,flag还是0,证明在遍历的过程中没有走过if
         */
        if (flag==0){
            System.out.println(-1);
        }
    }
}
```

## 7.练习_数组复制

```

```



## 8.练习_数组扩容

```
数组扩容
    
需求:
  定义一个数组:int[] arr1 = {1,2,3,4,5}
             将数组由原来的长度扩容到10
```

```java
public class Demo04Array {
    public static void main(String[] args) {
        int[] oldArr = {1,2,3,4,5};
        //创建新数组
        int[] newArr = new int[10];

        //将老数组中的元素复制到新数组中

        for (int i = 0; i < oldArr.length; i++) {
            newArr[i] = oldArr[i];
        }

        //将新数组中的地址值给老数组
        oldArr = newArr;

        //遍历oldArr
        System.out.println(oldArr.length);

        System.out.println("==================");

        for (int i = 0; i < oldArr.length; i++) {
            System.out.println(oldArr[i]);
        }
    }
}
```

<img src="img/1699000658991.png" alt="1699000658991" style="zoom:80%;" />

## 9.练习_数组合并

```java
数组合并
    
int[] arr1 = {1,2,3}
int[] arr2 = {4,5,6}
```

```java
public class Demo05Array {
    public static void main(String[] args) {
        int[] arr1 = {1,2,3};
        int[] arr2 = {4,5,6};

        //创建新数组
        int[] newArr = new int[arr1.length+arr2.length];

        for (int i = 0; i < arr1.length; i++) {
            newArr[i] = arr1[i];
        }

        /*
          由于已经保存了arr1的三个元素
          所以我们保存arr2的元素时,就不能从索引0开始了,不然从arr1中保存的元素会被arr2的元素覆盖

          arr2的元素需要从newArr的索引3开始保存
         */
        //先获取arr1的长度为3
        int len = arr1.length;

        for (int i = 0; i < arr2.length; i++) {

            /*
              newArr[3+0] = arr2[0] ;i++
              newArr[3+1] = arr2[1] ;i++
              newArr[3+2] = arr2[2] 
             */
            newArr[len+i] = arr2[i];
        }


        for (int i = 0; i < newArr.length; i++) {
            System.out.print(newArr[i]+"  ");
        }
    }
}

```

<img src="img/1699000686275.png" alt="1699000686275" style="zoom:80%;" />

# 第五章.内存图

```java
1.内存:可以理解"内存条",任何程序,软件运行起来都会在内存中运行,占用内存,在java的世界中,将内存分为了5大块
    
2.分为哪5大块
  栈(重点)(Stack)
    主要运行方法,方法的运行都会去栈内存中运行,运行完毕之后,需要"弹栈",腾空间
    
  堆(重点):(Heap)
    每new一次,都会在堆内存中开辟空间,并为此空间自动分配一个地址值
    堆中的数据都是有默认值的
    整数:0
    小数:0.0
    字符: '\u0000'
    布尔:false
    引用:null    
        
  方法区(重点)(Method Area)
    代码的"预备区",记录了类的信息以及方法的信息

  本地方法栈(了解):专门运行native方法(本地方法)
    本地方法可以理解为对java功能的扩充 
    有很多功能java语言实现不了,所以就需要依靠本地方法完成
        
  寄存器(了解) -> 跟CPU有关
```

<img src="img/1693125937484.png" alt="1693125937484" style="zoom:80%;" />

## 1.一个数组内存图

<img src="img/1699000833517.png" alt="1699000833517" style="zoom:80%;" />

## 2.两个数组内存图

```java
我们创建了两个数组,在堆内存中开辟了两个不同的空间,此时修改一个数组中的元素不会影响到另外一个数组中的数据
```

<img src="img/1699000841735.png" alt="1699000841735" style="zoom:80%;" />

## 3.两个数组指向同一片内存空间

```java
arr2不是new出来的,是arr1直接赋值的,arr1在内存中保存的是地址值,给了arr2,那么arr2的地址值和arr1就是一样的
所以此时arr1和arr2指向了堆内存中的同一片空间(同一个地址值,同一个数组),此时改变一个数组中的元素会影响到另外一个数组
```

<img src="img/1699000850332.png" alt="1699000850332" style="zoom:80%;" />



# 第六章.二维数组

## 1.二维数组的定义格式

```java
1.概述:数组中的套多个数组
2.定义格式
  a.动态初始化
    数据类型[][] 数组名 = new 数据类型[m][n]
    数据类型 数组名[][] = new 数据类型[m][n]
    数据类型[] 数组名[] = new 数据类型[m][n]
    
    m:代表的是二维数组的长度
    n:代表的是二维数组中每一个一维数组的长度
    
    数据类型[][] 数组名 = new 数据类型[m][] -> 二维数组中的一维数组没有被创建  
        
  b.静态初始化
    数据类型[][] 数组名 = new 数据类型[][]{{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}}
    数据类型 数组名[][] = new 数据类型[][]{{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}}
    数据类型[] 数组名[] = new 数据类型[][]{{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}}

  c.简化静态初始化:
    数据类型[][] 数组名 = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}}
    数据类型 数组名[][] = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}}
    数据类型[] 数组名[] = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}}
```

<img src="img/1699000860190.png" alt="1699000860190" style="zoom:80%;" />

```java
public class Demo01Array {
    public static void main(String[] args) {
        int[][] arr1 = new int[2][2];

        int[][] arr2 = new int[2][];

        System.out.println("======================");

        String[][] arr3 = {{"孙悟空","唐僧"},{"刘备","关羽","张飞"},{"宋江"},{"林黛玉","贾宝玉","王熙凤","薛宝钗"}};
    }
}
```

## 2.获取二维数组长度

```java
1.格式:
  数组名.length
      
2.获取每一个一维数组长度,需要先遍历二维数组,将每一个一维数组从二维数组中拿出来      
```

```java
public class Demo02Array {
    public static void main(String[] args) {
        String[][] arr = {{"张三","李四"},{"王五","赵六","田七"},{"猪八","牛九"}};
        System.out.println(arr.length);
        for (int i = 0; i < arr.length; i++) {
            /*
             arr[i]代表的是每一个一维数组
             */
            System.out.println(arr[i].length);
        }
    }
}

```

## 3.获取二维数组中的元素

```java
1.格式:
  数组名[i][j]
      
  i:代表的是一维数组在二维数组中的索引位置
  j:代表的是元素在一维数组中的索引位置
```

```java
public class Demo03Array {
    public static void main(String[] args) {
        String[][] arr = {{"张三","李四"},{"王五","赵六","田七"},{"猪八","牛九"}};
        System.out.println(arr[0][0]);
        System.out.println(arr[2][0]);
        System.out.println(arr[1][1]);
    }
}
```

<img src="img/1699000869540.png" alt="1699000869540" style="zoom:80%;" />

## 4.二维数组中存储元素

```java
1.格式:
  数组名[i][j] = 值
      
  i:代表的是一维数组在二维数组中的索引位置
  j:代表的是元素在一维数组中的索引位置
```

```java
public class Demo04Array {
    public static void main(String[] args) {
        String[][] arr = new String[2][2];
        arr[0][0] = "张飞";
        arr[0][1] = "李逵";
        arr[1][0] = "刘备";
        arr[1][1] = "宋江";


        System.out.println(arr[0][0]);
        System.out.println(arr[0][1]);
        System.out.println(arr[1][0]);
        System.out.println(arr[1][1]);
    }
}

```

## 5.二维数组的遍历

```java
1.先遍历二维数组,将每一个一维数组遍历出来
2.再遍历每一个一维数组,将元素获取出来
```

```java
public class Demo05Array {
    public static void main(String[] args) {
        String[][] arr = new String[2][2];
        arr[0][0] = "张飞";
        arr[0][1] = "李逵";
        arr[1][0] = "刘备";
        arr[1][1] = "宋江";


        //遍历二维数组
        for (int i = 0; i < arr.length; i++) {
            /*
              arr[i]代表的每一个一维数组
             */
            for (int j = 0; j < arr[i].length; j++) {
                System.out.println(arr[i][j]);
            }
        }
    }
}

```

## 6.二维数组内存图

```java
public class Demo06Array {
    public static void main(String[] args) {
        int[][] arr1 = new int[3][];

        arr1[1] = new int[]{1,2,3};

        arr1[2] = new int[3];

        arr1[2][1] = 100;
    }
}
```

![1693280082069](img/1693280082069.png)

